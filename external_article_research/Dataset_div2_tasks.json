{
  "/contest/1715": [
    {
      "problem": "A",
      "task": "A. Crossmarket\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nStanley and Megan decided to shop in the \"Crossmarket\" grocery store, which can be represented as a matrix with n\nrows and m\n\ncolumns.\n\nStanley and Megan can move to an adjacent cell using 1\nunit of power. Two cells are considered adjacent if they share an edge. To speed up the shopping process, Megan brought her portals with her, and she leaves one in each cell she visits (if there is no portal yet). If a person (Stanley or Megan) is in a cell with a portal, that person can use 1\n\nunit of power to teleport to any other cell with a portal, including Megan's starting cell.\n\nThey decided to split up: Stanley will go from the upper-left cell (cell with coordinates (1,1)\n) to the lower-right cell (cell with coordinates (n,m)), whilst Megan needs to get from the lower-left cell (cell with coordinates (n,1)) to the upper-right cell (cell with coordinates (1,m)\n\n).\n\nWhat is the minimum total energy needed for them both to do that?\n\nNote that they can choose the time they move. Time does not affect energy.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤1000\n\n). Description of the test cases follows.\n\nThe only line in the test case contains two integers n\nand m (1≤n,m≤105\n\n).\nOutput\n\nFor each test case print a single integer on a new line – the answer.\nExample\nInput\nCopy\n\n7\n7 5\n5 7\n1 1\n100000 100000\n57 228\n1 5\n5 1\n\nOutput\nCopy\n\n15\n15\n0\n299998\n340\n5\n5\n\nNote\n\nIn the first test case they can stick to the following plan:\n\n    Megan (red circle) moves to the cell (7,3)\n\n. Then she goes to the cell (1,3)\n, and Stanley (blue circle) does the same.\nStanley uses the portal in that cell (cells with portals are grey) to get to the cell (7,3)\n. Then he moves to his destination — cell (7,5)\n.\nMegan also finishes her route and goes to the cell (1,5)\n\n    . \n\nThe total energy spent is (2+6)+(2+1+2)+(2)=15\n\n, which is our final answer.\n\n\n"
    },
    {
      "problem": "B",
      "task": "B. Beautiful Array\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nStanley defines the beauty of an array a\nof length n, which contains non-negative integers, as follows:\n∑i=1n⌊aik⌋,\nwhich means that we divide each element by k\n\n, round it down, and sum up the resulting values.\n\nStanley told Sam the integer k\nand asked him to find an array a of n non-negative integers, such that the beauty is equal to b and the sum of elements is equal to s\n\n. Help Sam — find any of the arrays satisfying the conditions above.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤1000\n\n). Description of the test cases follows.\n\nThe first line of each test case contains integers n\n, k, b, s (1≤n≤105, 1≤k≤109, 0≤b≤109, 0≤s≤1018\n\n).\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each test case print −1\nif such array a does not exist. Otherwise print n non-negative integers a1,a2,…,an (0≤ai≤1018\n\n) — the answer.\nExample\nInput\nCopy\n\n8\n1 6 3 100\n3 6 3 12\n3 6 3 19\n5 4 7 38\n5 4 7 80\n99978 1000000000 100000000 1000000000000000000\n1 1 0 0\n4 1000000000 1000000000 1000000000000000000\n\nOutput\nCopy\n\n-1\n-1\n0 0 19\n0 3 3 3 29\n-1\n-1\n0\n0 0 0 1000000000000000000\n\nNote\n\nIn the first, the second, the fifth and the sixth test cases of the example it is possible to show that such array does not exist.\n\nIn the third testcase of the example a=[0,0,19]\n. The sum of elements in it is equal to 19, the beauty of it is equal to (⌊06⌋+⌊06⌋+⌊196⌋)=(0+0+3)=3\n\n.\n\nIn the fourth testcase of the example a=[0,3,3,3,29]\n. The sum of elements in it is equal to 38, the beauty of it is equal to (0+0+0+0+7)=7."
    },
    {
      "problem": "C",
      "task": "C. Monoblock\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nStanley has decided to buy a new desktop PC made by the company \"Monoblock\", and to solve captcha on their website, he needs to solve the following task.\n\nThe awesomeness of an array is the minimum number of blocks of consecutive identical numbers in which the array could be split. For example, the awesomeness of an array\n\n    [1,1,1]\n\nis 1\n;\n[5,7]\nis 2, as it could be split into blocks [5] and [7]\n;\n[1,7,7,7,7,7,7,7,9,9,9,9,9,9,9,9,9]\nis 3, as it could be split into blocks [1], [7,7,7,7,7,7,7], and [9,9,9,9,9,9,9,9,9]\n\n    . \n\nYou are given an array a\nof length n. There are m queries of two integers i, x. A query i, x means that from now on the i-th element of the array a is equal to x\n\n.\n\nAfter each query print the sum of awesomeness values among all subsegments of array a\n. In other words, after each query you need to calculate\n∑l=1n∑r=lng(l,r),\nwhere g(l,r) is the awesomeness of the array b=[al,al+1,…,ar]\n\n.\nInput\n\nIn the first line you are given with two integers n\nand m (1≤n,m≤105\n\n).\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤109) — the array a\n\n.\n\nIn the next m\nlines you are given the descriptions of queries. Each line contains two integers i and x (1≤i≤n, 1≤x≤109\n\n).\nOutput\n\nPrint the answer to each query on a new line.\nExample\nInput\nCopy\n\n5 5\n1 2 3 4 5\n3 2\n4 2\n3 1\n2 1\n2 2\n\nOutput\nCopy\n\n29\n23\n35\n25\n35\n\nNote\n\nAfter the first query a\nis equal to [1,2,2,4,5], and the answer is 29\n\nbecause we can split each of the subsegments the following way:\n\n    [1;1]\n\n: [1]\n, 1 block;\n[1;2]\n: [1]+[2]\n, 2 blocks;\n[1;3]\n: [1]+[2,2]\n, 2 blocks;\n[1;4]\n: [1]+[2,2]+[4]\n, 3 blocks;\n[1;5]\n: [1]+[2,2]+[4]+[5]\n, 4 blocks;\n[2;2]\n: [2]\n, 1 block;\n[2;3]\n: [2,2]\n, 1 block;\n[2;4]\n: [2,2]+[4]\n, 2 blocks;\n[2;5]\n: [2,2]+[4]+[5]\n, 3 blocks;\n[3;3]\n: [2]\n, 1 block;\n[3;4]\n: [2]+[4]\n, 2 blocks;\n[3;5]\n: [2]+[4]+[5]\n, 3 blocks;\n[4;4]\n: [4]\n, 1 block;\n[4;5]\n: [4]+[5]\n, 2 blocks;\n[5;5]\n: [5]\n\n    , 1 block; \n\nwhich is 1+2+2+3+4+1+1+2+3+1+2+3+1+2+1=29 in total."
    },
    {
      "problem": "D",
      "task": "D. 2+ doors\ntime limit per test\n1.5 seconds\nmemory limit per test\n256 megabytes\n\nThe Narrator has an integer array a\nof length n, but he will only tell you the size n and q statements, each of them being three integers i,j,x, which means that ai∣aj=x, where |\n\ndenotes the bitwise OR operation.\n\nFind the lexicographically smallest array a\n\nthat satisfies all the statements.\n\nAn array a\nis lexicographically smaller than an array b\n\nof the same length if and only if the following holds:\n\n    in the first position where a\n\nand b differ, the array a has a smaller element than the corresponding element in b\n\n    . \n\nInput\n\nIn the first line you are given with two integers n\nand q (1≤n≤105, 0≤q≤2⋅105\n\n).\n\nIn the next q\nlines you are given with three integers i, j, and x (1≤i,j≤n, 0≤x<230\n\n) — the statements.\n\nIt is guaranteed that all q\n\nstatements hold for at least one array.\nOutput\n\nOn a single line print n\nintegers a1,a2,…,an (0≤ai<230) — array a\n\n.\nExamples\nInput\nCopy\n\n4 3\n1 2 3\n1 3 2\n4 1 2\n\nOutput\nCopy\n\n0 3 2 2 \n\nInput\nCopy\n\n1 0\n\nOutput\nCopy\n\n0 \n\nInput\nCopy\n\n2 1\n1 1 1073741823\n\nOutput\nCopy\n\n1073741823 0 \n\nNote\n\nIn the first sample, these are all the arrays satisfying the statements:\n\n    [0,3,2,2]\n\n,\n[2,1,0,0]\n,\n[2,1,0,2]\n,\n[2,1,2,0]\n,\n[2,1,2,2]\n,\n[2,3,0,0]\n,\n[2,3,0,2]\n,\n[2,3,2,0]\n,\n[2,3,2,2]\n. "
    },
    {
      "problem": "E",
      "task": "E. Long Way Home\ntime limit per test\n3 seconds\nmemory limit per test\n256 megabytes\n\nStanley lives in a country that consists of n\ncities (he lives in city 1). There are bidirectional roads between some of the cities, and you know how long it takes to ride through each of them. Additionally, there is a flight between each pair of cities, the flight between cities u and v takes (u−v)2\n\ntime.\n\nStanley is quite afraid of flying because of watching \"Sully: Miracle on the Hudson\" recently, so he can take at most k\nflights. Stanley wants to know the minimum time of a journey to each of the n cities from the city 1\n\n.\nInput\n\nIn the first line of input there are three integers n\n, m, and k (2≤n≤105, 1≤m≤105, 1≤k≤20\n\n) — the number of cities, the number of roads, and the maximal number of flights Stanley can take.\n\nThe following m\nlines describe the roads. Each contains three integers u, v, w (1≤u,v≤n, u≠v, 1≤w≤109\n\n) — the cities the road connects and the time it takes to ride through. Note that some pairs of cities may be connected by more than one road.\nOutput\n\nPrint n\nintegers, i-th of which is equal to the minimum time of traveling to city i\n\n.\nExamples\nInput\nCopy\n\n3 1 2\n1 3 1\n\nOutput\nCopy\n\n0 1 1 \n\nInput\nCopy\n\n4 3 1\n1 2 3\n2 4 5\n3 4 7\n\nOutput\nCopy\n\n0 1 4 6 \n\nInput\nCopy\n\n2 1 1\n2 1 893746473\n\nOutput\nCopy\n\n0 1 \n\nInput\nCopy\n\n5 5 2\n2 1 33\n1 5 93\n5 3 48\n2 3 21\n4 2 1\n\nOutput\nCopy\n\n0 1 2 2 3 \n\nNote\n\nIn the first sample, it takes no time to get to city 1; to get to city 2 it is possible to use a flight between 1 and 2, which will take 1 unit of time; to city 3 you can get via a road from city 1, which will take 1 unit of time.\n\nIn the second sample, it also takes no time to get to city 1. To get to city 2 Stanley should use a flight between 1 and 2, which will take 1 unit of time. To get to city 3 Stanley can ride between cities 1 and 2, which will take 3 units of time, and then use a flight between 2 and 3. To get to city 4 Stanley should use a flight between 1 and 2, then take a ride from 2 to 4, which will take 5 units of time.\n\n"
    },
    {
      "problem": "F",
      "task": "F. Crop Squares\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nThis is an interactive problem.\n\nFarmer Stanley grows corn on a rectangular field of size n×m\nmeters with corners in points (0,0), (0,m), (n,0), (n,m)\n\n. This year the harvest was plentiful and corn covered the whole field.\n\nThe night before harvest aliens arrived and poisoned the corn in a single 1×1\nsquare with sides parallel to field borders. The corn inside the square must not be eaten, but you cannot distinguish it from ordinary corn by sight. Stanley can only collect a sample of corn from an arbitrary polygon and bring it to the laboratory, where it will be analyzed and Stanley will be told the amount of corn in the sample that was poisoned. Since the harvest will soon deteriorate, such a study can be carried out no more than 5\n\ntimes.\n\nMore formally, it is allowed to make no more than 5\nqueries, each of them calculates the area of intersection of a chosen polygon with a square of poisoned corn. It is necessary to find out the coordinates of the lower-left corner of the drawn square (the vertex of the square with the smallest x and y\n\ncoordinates).\nInput\n\nFirst line contains two integers n\nand m (1≤n,m≤100\n\n) — field sizes.\nInteraction\n\nIn order to query the area of intersection of a polygon with k\n(3≤k≤1000) vertices at points with coordinates (x1,y1),…,(xk,yk) with a square of poisoned corn print k+1 lines. In the first of these lines print \"? k\". In the i-th of the next k lines print two real numbers xi and yi (|xi|,|yi|≤104) with at most 15\n\ndigits after decimal place.\n\nThe polygon must have strictly positive area and contain no self-intersections.\n\nIn response to this query you will receive a real number s\n(0≤s≤1) with 15\n\ndigits after decimal place — the area of intersection of the square with the given polygon. If the polygon is invalid, there is no guarantee on the valid response.\n\nWhen you have identified the drawn square, print on a separate line \"! x y\", where x\nand y are real numbers with at most 15 digits after decimal place representing the coordinates of its lower-left corner (0≤x≤n−1, 0≤y≤m−1\n\n), and then you have to terminate your program.\n\nYour answer will be considered correct if its absolute or relative error on both coordinates does not exceed 10−6\n. Formally let your answer be a, jury answer be b. Your answer will be considered correct if |a−b|max(1,|b|)≤10−6\n\n.\n\nAfter printing a query do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n    fflush(stdout) or cout.flush() in C++;\n    System.out.flush() in Java;\n    flush(output) in Pascal;\n    stdout.flush() in Python;\n    see documentation for other languages. \n\nHacks\n\nTo make a hack, use the following test format.\n\nThe first line of the input should contain two integers n\nand m (1≤n,m≤100\n\n) — field sizes.\n\nThe second line should contain two real numbers x\n(0≤x≤n−1) and y (0≤y≤m−1\n\n) — coordinates of the lower-left corner of the square of poisoned corn.\nExample\nInput\nCopy\n\n3 3\n\n\n\n\n\n0.5\n\n\n\n\n\n0.5\n\nOutput\nCopy\n\n? 4\n0 0\n2 0\n2 3\n0 3\n\n? 4\n0 0\n0 1\n3 1\n3 0\n\n! 1.5 0.5\n\nNote\n\nIn the first test from the statement, the aliens poisoned a square of corn with vertices at points with coordinates (1.5,0.5)\n, (1.5,1.5), (2.5,1.5), (2.5,0.5)\n\n. In the picture, it is red, the polygon selected in the query is blue, and their intersection is green.\n\nPicture for the first query:\n\nPicture for the second query:\n\n\n"
    }
  ],
  "/contest/1712": [
    {
      "problem": "A",
      "task": "A. Wonderful Permutation\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\nGod's Blessing on This PermutationForces!\nA Random Pebble\n\nYou are given a permutation p1,p2,…,pn\nof length n and a positive integer k≤n\n\n.\n\nIn one operation you can choose two indices i\nand j (1≤i<j≤n) and swap pi with pj\n\n.\n\nFind the minimum number of operations needed to make the sum p1+p2+…+pk\n\nas small as possible.\n\nA permutation is an array consisting of n\ndistinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4\n\nin the array).\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤100\n\n). Description of the test cases follows.\n\nThe first line of each test case contains two integers n\nand k (1≤k≤n≤100\n\n).\n\nThe second line of each test case contains n\nintegers p1,p2,…,pn (1≤pi≤n). It is guaranteed that the given numbers form a permutation of length n\n\n.\nOutput\n\nFor each test case print one integer — the minimum number of operations needed to make the sum p1+p2+…+pk\n\nas small as possible.\nExample\nInput\nCopy\n\n4\n3 1\n2 3 1\n3 3\n1 2 3\n4 2\n3 4 1 2\n1 1\n1\n\nOutput\nCopy\n\n1\n0\n2\n0\n\nNote\n\nIn the first test case, the value of p1+p2+…+pk\nis initially equal to 2, but the smallest possible value is 1. You can achieve it by swapping p1 with p3, resulting in the permutation [1,3,2]\n\n.\n\nIn the second test case, the sum is already as small as possible, so the answer is 0\n\n.\n\n"
    },
    {
      "problem": "B",
      "task": "B. Woeful Permutation\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\nI wonder, does the falling rain\nForever yearn for it's disdain?\nEffluvium of the Mind\n\nYou are given a positive integer n\n\n.\n\nFind any permutation p\nof length n such that the sum lcm(1,p1)+lcm(2,p2)+…+lcm(n,pn)\n\nis as large as possible.\n\nHere lcm(x,y)\ndenotes the least common multiple (LCM) of integers x and y\n\n.\n\nA permutation is an array consisting of n\ndistinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4\n\nin the array).\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤1000\n\n). Description of the test cases follows.\n\nThe only line for each test case contains a single integer n\n(1≤n≤105\n\n).\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each test case print n\nintegers p1, p2, …, pn — the permutation with the maximum possible value of lcm(1,p1)+lcm(2,p2)+…+lcm(n,pn)\n\n.\n\nIf there are multiple answers, print any of them.\nExample\nInput\nCopy\n\n2\n1\n2\n\nOutput\nCopy\n\n1 \n2 1 \n\nNote\n\nFor n=1\n, there is only one permutation, so the answer is [1]\n\n.\n\nFor n=2\n\n, there are two permutations:\n\n    [1,2]\n\n — the sum is lcm(1,1)+lcm(2,2)=1+2=3\n.\n[2,1]\n — the sum is lcm(1,2)+lcm(2,1)=2+2=4. "
    },
    {
      "problem": "C",
      "task": "C. Sort Zero\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\nAn array is sorted if it has no inversions\nA Young Boy\n\nYou are given an array of n\npositive integers a1,a2,…,an\n\n.\n\nIn one operation you do the following:\n\n    Choose any integer x\n\n.\nFor all i\nsuch that ai=x, do ai:=0 (assign 0 to ai\n\n    ). \n\nFind the minimum number of operations required to sort the array in non-decreasing order.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤104\n\n). Description of the test cases follows.\n\nThe first line of each test case contains a single integer n\n(1≤n≤105\n\n).\n\nThe second line of each test case contains n\npositive integers a1,a2,…,an (1≤ai≤n\n\n).\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each test case print one integer — the minimum number of operations required to sort the array in non-decreasing order.\nExample\nInput\nCopy\n\n5\n3\n3 3 2\n4\n1 3 1 3\n5\n4 1 5 3 2\n4\n2 4 1 2\n1\n1\n\nOutput\nCopy\n\n1\n2\n4\n3\n0\n\nNote\n\nIn the first test case, you can choose x=3\nfor the operation, the resulting array is [0,0,2]\n\n.\n\nIn the second test case, you can choose x=1\nfor the first operation and x=3 for the second operation, the resulting array is [0,0,0,0]."
    },
    {
      "problem": "D",
      "task": "D. Empty Graph\ntime limit per test\n1.5 seconds\nmemory limit per test\n256 megabytes\n — Do you have a wish?\n — I want people to stop gifting each other arrays.\nO_o and Another Young Boy\n\nAn array of n\npositive integers a1,a2,…,an fell down on you from the skies, along with a positive integer k≤n\n\n.\n\nYou can apply the following operation at most k\n\ntimes:\n\n    Choose an index 1≤i≤n\n\nand an integer 1≤x≤109. Then do ai:=x (assign x to ai\n\n    ). \n\nThen build a complete undirected weighted graph with n\nvertices numbered with integers from 1 to n, where edge (l,r) (1≤l<r≤n) has weight min(al,al+1,…,ar)\n\n.\n\nYou have to find the maximum possible diameter of the resulting graph after performing at most k\n\noperations.\n\nThe diameter of a graph is equal to max1≤u<v≤nd(u,v)\n, where d(u,v) is the length of the shortest path between vertex u and vertex v\n\n.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤104\n\n). Description of the test cases follows.\n\nThe first line of each test case contains two integers n\nand k (2≤n≤105, 1≤k≤n\n\n).\n\nThe second line of each test case contains n\npositive integers a1,a2,…,an (1≤ai≤109\n\n).\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each test case print one integer — the maximum possible diameter of the graph after performing at most k\n\noperations.\nExample\nInput\nCopy\n\n6\n3 1\n2 4 1\n3 2\n1 9 84\n3 1\n10 2 6\n3 2\n179 17 1000000000\n2 1\n5 9\n2 2\n4 2\n\nOutput\nCopy\n\n4\n168\n10\n1000000000\n9\n1000000000\n\nNote\n\nIn the first test case, one of the optimal arrays is [2,4,5]\n\n.\n\nThe graph built on this array:\n\nd(1,2)=d(1,3)=2\nand d(2,3)=4, so the diameter is equal to max(2,2,4)=4."
    },
    {
      "problem": "E1",
      "task": "E1. LCM Sum (easy version)\ntime limit per test\n3.5 seconds\nmemory limit per test\n512 megabytes\nWe are sum for we are many\nSome Number\n\nThis version of the problem differs from the next one only in the constraint on t\n\n. You can make hacks only if both versions of the problem are solved.\n\nYou are given two positive integers l\nand r\n\n.\n\nCount the number of distinct triplets of integers (i,j,k)\nsuch that l≤i<j<k≤r and lcm(i,j,k)≥i+j+k\n\n.\n\nHere lcm(i,j,k)\ndenotes the least common multiple (LCM) of integers i, j, and k\n\n.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤5\n\n). Description of the test cases follows.\n\nThe only line for each test case contains two integers l\nand r (1≤l≤r≤2⋅105, l+2≤r\n\n).\nOutput\n\nFor each test case print one integer — the number of suitable triplets.\nExample\nInput\nCopy\n\n5\n1 4\n3 5\n8 86\n68 86\n6 86868\n\nOutput\nCopy\n\n3\n1\n78975\n969\n109229059713337\n\nNote\n\nIn the first test case, there are 3\n\nsuitable triplets:\n\n    (1,2,3)\n\n,\n(1,3,4)\n,\n(2,3,4)\n\n    . \n\nIn the second test case, there is 1\n\nsuitable triplet:\n\n    (3,4,5)\n\n. "
    },
    {
      "problem": "E2",
      "task": "E2. LCM Sum (hard version)\ntime limit per test\n3.5 seconds\nmemory limit per test\n512 megabytes\nWe are sum for we are many\nSome Number\n\nThis version of the problem differs from the previous one only in the constraint on t\n\n. You can make hacks only if both versions of the problem are solved.\n\nYou are given two positive integers l\nand r\n\n.\n\nCount the number of distinct triplets of integers (i,j,k)\nsuch that l≤i<j<k≤r and lcm(i,j,k)≥i+j+k\n\n.\n\nHere lcm(i,j,k)\ndenotes the least common multiple (LCM) of integers i, j, and k\n\n.\nInput\n\nEach test contains multiple test cases. The first line contains the number of test cases t\n(1≤t≤105\n\n). Description of the test cases follows.\n\nThe only line for each test case contains two integers l\nand r (1≤l≤r≤2⋅105, l+2≤r\n\n).\nOutput\n\nFor each test case print one integer — the number of suitable triplets.\nExample\nInput\nCopy\n\n5\n1 4\n3 5\n8 86\n68 86\n6 86868\n\nOutput\nCopy\n\n3\n1\n78975\n969\n109229059713337\n\nNote\n\nIn the first test case, there are 3\n\nsuitable triplets:\n\n    (1,2,3)\n\n,\n(1,3,4)\n,\n(2,3,4)\n\n    . \n\nIn the second test case, there is 1\n\nsuitable triplet:\n\n    (3,4,5)\n\n    . \n\n"
    },
    {
      "problem": "F",
      "task": "F. Triameter\ntime limit per test\n4.5 seconds\nmemory limit per test\n768 megabytes\n — What is my mission?\n — To count graph diameters.\nYou and Your Submission\n\nA tree is a connected undirected graph without cycles. A weighted tree has a weight assigned to each edge. The degree of a vertex is the number of edges connected to this vertex.\n\nYou are given a weighted tree with n\nvertices, each edge has a weight of 1. Let L be the set of vertices with degree equal to 1\n\n.\n\nYou have to answer q\nindependent queries. In the i\n\n-th query:\n\n    You are given a positive integer xi\n\n.\nFor all u,v∈L\nsuch that u<v, add edge (u,v) with weight xi\n\n    to the graph (initially the given tree).\n    Find the diameter of the resulting graph. \n\nThe diameter of a graph is equal to max1≤u<v≤nd(u,v)\n, where d(u,v) is the length of the shortest path between vertex u and vertex v\n\n.\nInput\n\nThe first line contains a single integer n\n(3≤n≤106\n\n).\n\nThe second line contains n−1\nintegers p2,p3,…,pn (1≤pi<i) indicating that there is an edge between vertices i and pi\n\n. It is guaranteed that the given edges form a tree.\n\nThe third line contains a single integer q\n(1≤q≤10\n\n).\n\nThe fourth line contains q\nintegers x1,x2,…,xq (1≤xi≤n). All xi\n\nare distinct.\nOutput\n\nPrint q\n\nintegers in a single line — the answers to the queries.\nExamples\nInput\nCopy\n\n4\n1 2 2\n4\n1 2 3 4\n\nOutput\nCopy\n\n1 2 2 2 \n\nInput\nCopy\n\n7\n1 2 3 4 2 1\n7\n2 1 3 7 5 6 4\n\nOutput\nCopy\n\n3 3 4 5 5 5 4 \n\nInput\nCopy\n\n3\n1 2\n1\n1\n\nOutput\nCopy\n\n1 \n\nNote\n\nThe graph in the first test after adding the edges:\n"
    }
  ],
  "/contest/1720": [
    {
      "problem": "A",
      "task": "A. Burenka Plays with Fractions\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nBurenka came to kindergarden. This kindergarten is quite strange, so each kid there receives two fractions (ab\nand cd\n\n) with integer numerators and denominators. Then children are commanded to play with their fractions.\n\nBurenka is a clever kid, so she noticed that when she claps once, she can multiply numerator or denominator of one of her two fractions by any integer of her choice (but she can't multiply denominators by 0\n\n). Now she wants know the minimal number of claps to make her fractions equal (by value). Please help her and find the required number of claps!\nInput\n\nThe first line contains one integer t\n(1≤t≤104\n\n) — the number of test cases. Then follow the descriptions of each test case.\n\nThe only line of each test case contains four integers a\n, b, c and d (0≤a,c≤109, 1≤b,d≤109\n\n) — numerators and denominators of the fractions given to Burenka initially.\nOutput\n\nFor each test case print a single integer — the minimal number of claps Burenka needs to make her fractions equal.\nExample\nInput\nCopy\n\n8\n2 1 1 1\n6 3 2 1\n1 2 2 3\n0 1 0 100\n0 1 228 179\n100 3 25 6\n999999999 300000000 666666666 100000000\n33 15 0 84\n\nOutput\nCopy\n\n1\n0\n2\n0\n1\n1\n1\n1\n\nNote\n\nIn the first case, Burenka can multiply c\nby 2\n\n, then the fractions will be equal.\n\nIn the second case, fractions are already equal.\n\nIn the third case, Burenka can multiply a\nby 4, then b by 3. Then the fractions will be equal (1⋅42⋅3=23)."
    },
    {
      "problem": "B",
      "task": "B. Interesting Sum\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nYou are given an array a\nthat contains n integers. You can choose any proper subsegment al,al+1,…,ar of this array, meaning you can choose any two integers 1≤l≤r≤n, where r−l+1<n\n\n. We define the beauty of a given subsegment as the value of the following expression:\n\nmax(a1,a2,…,al−1,ar+1,ar+2,…,an)−min(a1,a2,…,al−1,ar+1,ar+2,…,an)+max(al,…,ar)−min(al,…,ar).\n\nPlease find the maximum beauty among all proper subsegments.\nInput\n\nThe first line contains one integer t\n(1≤t≤1000\n\n) — the number of test cases. Then follow the descriptions of each test case.\n\nThe first line of each test case contains a single integer n\n(4≤n≤105)\n\n— the length of the array.\n\nThe second line of each test case contains n\nintegers a1,a2,…,an (1≤ai≤109\n\n) — the elements of the given array.\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each testcase print a single integer — the maximum beauty of a proper subsegment.\nExample\nInput\nCopy\n\n4\n8\n1 2 2 3 1 5 6 1\n5\n1 2 3 100 200\n4\n3 3 3 3\n6\n7 8 3 1 1 8\n\nOutput\nCopy\n\n9\n297\n0\n14\n\nNote\n\nIn the first test case, the optimal segment is l=7\n, r=8. The beauty of this segment equals to (6−1)+(5−1)=9\n\n.\n\nIn the second test case, the optimal segment is l=2\n, r=4. The beauty of this segment equals (100−2)+(200−1)=297\n\n.\n\n"
    },
    {
      "problem": "C",
      "task": "C. Corners\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nYou are given a matrix consisting of n\nrows and m columns. Each cell of this matrix contains 0 or 1\n\n.\n\nLet's call a square of size 2×2\nwithout one corner cell an L-shape figure. In one operation you can take one L-shape figure, with at least one cell containing 1\n\nand replace all numbers in it with zeroes.\n\nFind the maximum number of operations that you can do with the given matrix.\nInput\n\nThe first line contains one integer t\n(1≤t≤500\n\n) — the number of test cases. Then follow the descriptions of each test case.\n\nThe first line of each test case contains two integers n\nand m (2≤n,m≤500\n\n) — the size of the matrix.\n\nEach of the following n\nlines contains a binary string of length m\n\n— the description of the matrix.\n\nIt is guaranteed that the sum of n\nand the sum of m over all test cases does not exceed 1000\n\n.\nOutput\n\nFor each test case output the maximum number of operations you can do with the given matrix.\nExample\nInput\nCopy\n\n4\n4 3\n101\n111\n011\n110\n3 4\n1110\n0111\n0111\n2 2\n00\n00\n2 2\n11\n11\n\nOutput\nCopy\n\n8\n9\n0\n2\n\nNote\n\nIn the first testcase one of the optimal sequences of operations is the following (bold font shows l-shape figure on which operation was performed):\n\n    Matrix before any operation was performed:\n    1\t0\t1\n    1\t1\t1\n    0\t1\t1\n    1\t1\t0\n    Matrix after 1\n\noperation was performed:\n1\t0\t0\n1\t0\t1\n0\t1\t1\n1\t1\t0\nMatrix after 2\noperations were performed:\n1\t0\t0\n1\t0\t0\n0\t1\t1\n1\t1\t0\nMatrix after 3\noperations were performed:\n1\t0\t0\n1\t0\t0\n0\t1\t0\n1\t1\t0\nMatrix after 4\noperations were performed:\n1\t0\t0\n0\t0\t0\n0\t1\t0\n1\t1\t0\nMatrix after 5\noperations were performed:\n1\t0\t0\n0\t0\t0\n0\t1\t0\n1\t0\t0\nMatrix after 6\noperations were performed:\n1\t0\t0\n0\t0\t0\n0\t0\t0\n1\t0\t0\nMatrix after 7\noperations were performed:\n0\t0\t0\n0\t0\t0\n0\t0\t0\n1\t0\t0\nMatrix after 8\n\n    operations were performed:\n    0\t0\t0\n    0\t0\t0\n    0\t0\t0\n    0\t0\t0\n\nIn the third testcase from the sample we can not perform any operation because the matrix doesn't contain any ones.\n\nIn the fourth testcase it does not matter which L-shape figure we pick in our first operation. We will always be left with single one. So we will perform 2\noperations."
    },
    {
      "problem": "D1",
      "task": "D1. Xor-Subsequence (easy version)\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nIt is the easy version of the problem. The only difference is that in this version ai≤200\n\n.\n\nYou are given an array of n\nintegers a0,a1,a2,…an−1\n\n. Bryap wants to find the longest beautiful subsequence in the array.\n\nAn array b=[b0,b1,…,bm−1]\n, where 0≤b0<b1<…<bm−1<n, is a subsequence of length m of the array a\n\n.\n\nSubsequence b=[b0,b1,…,bm−1]\nof length m\n\nis called beautiful, if the following condition holds:\n\n    For any p\n\n(0≤p<m−1) holds: abp⊕bp+1<abp+1⊕bp\n\n    . \n\nHere a⊕b\ndenotes the bitwise XOR of a and b. For example, 2⊕4=6 and 3⊕1=2\n\n.\n\nBryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.\nInput\n\nThe first line contains a single integer t\n(1≤t≤105\n\n)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n\n(2≤n≤3⋅105\n\n) — the length of the array.\n\nThe second line of each test case contains n\nintegers a0,a1,...,an−1 (0≤ai≤200\n\n) — the elements of the array.\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 3⋅105\n\n.\nOutput\n\nFor each test case print a single integer — the length of the longest beautiful subsequence.\nExample\nInput\nCopy\n\n3\n2\n1 2\n5\n5 2 4 3 1\n10\n3 8 8 2 9 1 6 2 8 3\n\nOutput\nCopy\n\n2\n3\n6\n\nNote\n\nIn the first test case, we can pick the whole array as a beautiful subsequence because 1⊕1<2⊕0\n\n.\n\nIn the second test case, we can pick elements with indexes 1\n, 2 and 4 (in 0-indexation). For this elements holds: 2⊕2<4⊕1 and 4⊕4<1⊕2."
    },
    {
      "problem": "D2",
      "task": "D2. Xor-Subsequence (hard version)\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nIt is the hard version of the problem. The only difference is that in this version ai≤109\n\n.\n\nYou are given an array of n\nintegers a0,a1,a2,…an−1\n\n. Bryap wants to find the longest beautiful subsequence in the array.\n\nAn array b=[b0,b1,…,bm−1]\n, where 0≤b0<b1<…<bm−1<n, is a subsequence of length m of the array a\n\n.\n\nSubsequence b=[b0,b1,…,bm−1]\nof length m\n\nis called beautiful, if the following condition holds:\n\n    For any p\n\n(0≤p<m−1) holds: abp⊕bp+1<abp+1⊕bp\n\n    . \n\nHere a⊕b\ndenotes the bitwise XOR of a and b. For example, 2⊕4=6 and 3⊕1=2\n\n.\n\nBryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.\nInput\n\nThe first line contains a single integer t\n(1≤t≤105\n\n)  — the number of test cases. The description of the test cases follows.\n\nThe first line of each test case contains a single integer n\n(2≤n≤3⋅105\n\n) — the length of the array.\n\nThe second line of each test case contains n\nintegers a0,a1,...,an−1 (0≤ai≤109\n\n) — the elements of the array.\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 3⋅105\n\n.\nOutput\n\nFor each test case print a single integer — the length of the longest beautiful subsequence.\nExample\nInput\nCopy\n\n3\n2\n1 2\n5\n5 2 4 3 1\n10\n3 8 8 2 9 1 6 2 8 3\n\nOutput\nCopy\n\n2\n3\n6\n\nNote\n\nIn the first test case, we can pick the whole array as a beautiful subsequence because 1⊕1<2⊕0\n\n.\n\nIn the second test case, we can pick elements with indexes 1\n, 2 and 4 (in 0 indexation). For this elements holds: 2⊕2<4⊕1 and 4⊕4<1⊕2."
    },
    {
      "problem": "E",
      "task": "E. Misha and Paintings\ntime limit per test\n3.5 seconds\nmemory limit per test\n256 megabytes\n\nMisha has a square n×n\nmatrix, where the number in row i and column j is equal to ai,j. Misha wants to modify the matrix to contain exactly k\n\ndistinct integers. To achieve this goal, Misha can perform the following operation zero or more times:\n\n    choose any square submatrix of the matrix (you choose (x1,y1)\n\n, (x2,y2), such that x1≤x2, y1≤y2, x2−x1=y2−y1, then submatrix is a set of cells with coordinates (x,y), such that x1≤x≤x2, y1≤y≤y2\n),\nchoose an integer k\n, where 1≤k≤n2\n,\nreplace all integers in the submatrix with k\n\n    . \n\nPlease find the minimum number of operations that Misha needs to achieve his goal.\nInput\n\nThe first input line contains two integers n\nand k (1≤n≤500,1≤k≤n2\n\n)  — the size of the matrix and the desired amount of distinct elements in the matrix.\n\nThen n\nlines follows. The i-th of them contains n integers ai,1,ai,2,…,ai,n (1≤ai,j≤n2) — the elements of the i\n\n-th row of the matrix.\nOutput\n\nOutput one integer — the minimum number of operations required.\nExamples\nInput\nCopy\n\n3 4\n1 1 1\n1 1 2\n3 4 5\n\nOutput\nCopy\n\n1\n\nInput\nCopy\n\n3 2\n2 1 3\n2 1 1\n3 1 2\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n3 3\n1 1 1\n1 1 2\n2 2 2\n\nOutput\nCopy\n\n1\n\nInput\nCopy\n\n3 2\n1 1 1\n1 2 1\n2 2 2\n\nOutput\nCopy\n\n0\n\nNote\n\nIn the first test case the answer is 1\n, because one can change the value in the bottom right corner of the matrix to 1\n\n. The resulting matrix can be found below:\n1\t1\t1\n1\t1\t2\n3\t4\t1\n\nIn the second test case the answer is 2\n. First, one can change the entire matrix to contain only 1s, and the change the value of any single cell to 2\n\n. One of the possible resulting matrices is displayed below:\n1\t1\t1\n1\t1\t1\n1\t1\t2"
    }
  ]
}