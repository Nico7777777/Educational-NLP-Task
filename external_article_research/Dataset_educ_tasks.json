{
    "/contest/1680": [
        {
            "problem": "A",
            "task": "A. Minimums and Maximums\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nAn array is beautiful if both of the following two conditions meet:\n\n    there are at least l1\n\nand at most r1\nelements in the array equal to its minimum;\nthere are at least l2\nand at most r2\n\n    elements in the array equal to its maximum. \n\nFor example, the array [2,3,2,4,4,3,2]\nhas 3 elements equal to its minimum (1-st, 3-rd and 7-th) and 2 elements equal to its maximum (4-th and 5\n\n-th).\n\nAnother example: the array [42,42,42]\nhas 3 elements equal to its minimum and 3\n\nelements equal to its maximum.\n\nYour task is to calculate the minimum possible number of elements in a beautiful array.\nInput\n\nThe first line contains one integer t\n(1≤t≤5000\n\n) — the number of test cases.\n\nEach test case consists of one line containing four integers l1\n, r1, l2 and r2 (1≤l1≤r1≤50; 1≤l2≤r2≤50\n\n).\nOutput\n\nFor each test case, print one integer — the minimum possible number of elements in a beautiful array.\nExample\nInput\nCopy\n\n7\n3 5 4 6\n5 8 5 5\n3 3 10 12\n1 5 3 3\n1 1 2 2\n2 2 1 1\n6 6 6 6\n\nOutput\nCopy\n\n4\n5\n13\n3\n3\n3\n6\n\nNote\n\nOptimal arrays in the test cases of the example:\n\n    [1,1,1,1]\n\n, it has 4 minimums and 4\nmaximums;\n[4,4,4,4,4]\n, it has 5 minimums and 5\nmaximums;\n[1,2,1,2,2,1,2,2,2,2,2,2,2]\n, it has 3 minimums and 10\nmaximums;\n[8,8,8]\n, it has 3 minimums and 3\nmaximums;\n[4,6,6]\n, it has 1 minimum and 2\nmaximums;\n[3,4,3]\n, it has 2 minimums and 1\nmaximum;\n[5,5,5,5,5,5]\n, it has 6 minimums and 6 maximums. "
        },
        {
            "problem": "B",
            "task": "B. Robots\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nThere is a field divided into n\nrows and m\n\ncolumns. Some cells are empty (denoted as E), other cells contain robots (denoted as R).\n\nYou can send a command to all robots at the same time. The command can be of one of the four types:\n\n    move up;\n    move right;\n    move down;\n    move left. \n\nWhen you send a command, all robots at the same time attempt to take one step in the direction you picked. If a robot tries to move outside the field, it explodes; otherwise, every robot moves to an adjacent cell in the chosen direction.\n\nYou can send as many commands as you want (possibly, zero), in any order. Your goal is to make at least one robot reach the upper left corner of the field. Can you do this without forcing any of the robots to explode?\nInput\n\nThe first line contains one integer t\n(1≤t≤5000\n\n) — the number of test cases.\n\nEach test case starts with a line containing two integers n\nand m (1≤n,m≤5) — the number of rows and the number of columns, respectively. Then n lines follow; each of them contains a string of m\n\ncharacters. Each character is either E (empty cell} or R (robot).\n\nAdditional constraint on the input: in each test case, there is at least one robot on the field.\nOutput\n\nIf it is possible to make at least one robot reach the upper left corner of the field so that no robot explodes, print YES. Otherwise, print NO.\nExample\nInput\nCopy\n\n6\n1 3\nERR\n2 2\nER\nRE\n2 2\nER\nER\n1 1\nR\n4 3\nEEE\nEEE\nERR\nEER\n3 3\nEEE\nEER\nREE\n\nOutput\nCopy\n\nYES\nNO\nYES\nYES\nYES\nNO\n\nNote\n\nExplanations for test cases of the example:\n\n    in the first test case, it is enough to send a command to move left.\n    in the second test case, if you try to send any command, at least one robot explodes.\n    in the third test case, it is enough to send a command to move left.\n    in the fourth test case, there is already a robot in the upper left corner.\n    in the fifth test case, the sequence \"move up, move left, move up\" leads one robot to the upper left corner;\n    in the sixth test case, if you try to move any robot to the upper left corner, at least one other robot explodes. "
        },
        {
            "problem": "C",
            "task": "C. Binary String\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a string s\n\nconsisting of characters 0 and/or 1.\n\nYou have to remove several (possibly zero) characters from the beginning of the string, and then several (possibly zero) characters from the end of the string. The string may become empty after the removals. The cost of the removal is the maximum of the following two values:\n\n    the number of characters 0 left in the string;\n    the number of characters 1 removed from the string. \n\nWhat is the minimum cost of removal you can achieve?\nInput\n\nThe first line contains one integer t\n(1≤t≤104\n\n) — the number of test cases.\n\nEach test case consists of one line containing the string s\n(1≤|s|≤2⋅105\n\n), consisting of characters 0 and/or 1.\n\nThe total length of strings s\nin all test cases does not exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print one integer — the minimum cost of removal you can achieve.\nExample\nInput\nCopy\n\n5\n101110110\n1001001001001\n0000111111\n00000\n1111\n\nOutput\nCopy\n\n1\n3\n0\n0\n0\n\nNote\n\nConsider the test cases of the example:\n\n    in the first test case, it's possible to remove two characters from the beginning and one character from the end. Only one 1 is deleted, only one 0 remains, so the cost is 1\n\n;\nin the second test case, it's possible to remove three characters from the beginning and six characters from the end. Two characters 0 remain, three characters 1 are deleted, so the cost is 3\n;\nin the third test case, it's optimal to remove four characters from the beginning;\nin the fourth test case, it's optimal to remove the whole string;\nin the fifth test case, it's optimal to leave the string as it is. "
        },
        {
            "problem": "D",
            "task": "D. Dog Walking\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nYou are walking with your dog, and now you are at the promenade. The promenade can be represented as an infinite line. Initially, you are in the point 0\n\nwith your dog.\n\nYou decided to give some freedom to your dog, so you untied her and let her run for a while. Also, you watched what your dog is doing, so you have some writings about how she ran. During the i\n-th minute, the dog position changed from her previous position by the value ai (it means, that the dog ran for ai meters during the i-th minute). If ai is positive, the dog ran ai meters to the right, otherwise (if ai is negative) she ran ai\n\nmeters to the left.\n\nDuring some minutes, you were chatting with your friend, so you don't have writings about your dog movement during these minutes. These values ai\n\nequal zero.\n\nYou want your dog to return to you after the end of the walk, so the destination point of the dog after n\nminutes should be 0\n\n.\n\nNow you are wondering: what is the maximum possible number of different integer points of the line your dog could visit on her way, if you replace every 0\nwith some integer from −k to k (and your dog should return to 0 after the walk)? The dog visits an integer point if she runs through that point or reaches in it at the end of any minute. Point 0\n\nis always visited by the dog, since she is initially there.\n\nIf the dog cannot return to the point 0\nafter n\n\nminutes regardless of the integers you place, print -1.\nInput\n\nThe first line of the input contains two integers n\nand k (1≤n≤3000;1≤k≤109\n\n) — the number of minutes and the maximum possible speed of your dog during the minutes without records.\n\nThe second line of the input contains n\nintegers a1,a2,…,an (−109≤ai≤109), where ai is the number of meters your dog ran during the i-th minutes (to the left if ai is negative, to the right otherwise). If ai=0 then this value is unknown and can be replaced with any integer from the range [−k;k]\n\n.\nOutput\n\nIf the dog cannot return to the point 0\nafter n minutes regardless of the set of integers you place, print -1. Otherwise, print one integer — the maximum number of different integer points your dog could visit if you fill all the unknown values optimally and the dog will return to the point 0\n\nat the end of the walk.\nExamples\nInput\nCopy\n\n3 2\n5 0 -4\n\nOutput\nCopy\n\n6\n\nInput\nCopy\n\n6 4\n1 -2 0 3 -4 5\n\nOutput\nCopy\n\n7\n\nInput\nCopy\n\n3 1000000000\n0 0 0\n\nOutput\nCopy\n\n1000000001\n\nInput\nCopy\n\n5 9\n-7 -3 8 12 0\n\nOutput\nCopy\n\n-1\n\nInput\nCopy\n\n5 3\n-1 0 3 3 0\n\nOutput\nCopy\n\n7\n\nInput\nCopy\n\n5 4\n0 2 0 3 0\n\nOutput\nCopy\n\n9\n"
        },
        {
            "problem": "E",
            "task": "E. Moving Chips\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a board of size 2×n\n(2 rows, n\n\ncolumns). Some cells of the board contain chips. The chip is represented as '*', and an empty space is represented as '.'. It is guaranteed that there is at least one chip on the board.\n\nIn one move, you can choose any chip and move it to any adjacent (by side) cell of the board (if this cell is inside the board). It means that if the chip is in the first row, you can move it left, right or down (but it shouldn't leave the board). Same, if the chip is in the second row, you can move it left, right or up.\n\nIf the chip moves to the cell with another chip, the chip in the destination cell disappears (i. e. our chip captures it).\n\nYour task is to calculate the minimum number of moves required to leave exactly one chip on the board.\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤2⋅104) — the number of test cases. Then t\n\ntest cases follow.\n\nThe first line of the test case contains one integer n\n(1≤n≤2⋅105) — the length of the board. The second line of the test case contains the string s1 consisting of n characters '*' (chip) and/or '.' (empty cell). The third line of the test case contains the string s2 consisting of n\n\ncharacters '*' (chip) and/or '.' (empty cell).\n\nAdditional constraints on the input:\n\n    in each test case, there is at least one chip on a board;\n    the sum of n\n\nover all test cases does not exceed 2⋅105 (∑n≤2⋅105\n\n    ). \n\nOutput\n\nFor each test case, print one integer — the minimum number of moves required to leave exactly one chip on the board.\nExample\nInput\nCopy\n\n5\n1\n*\n.\n2\n.*\n**\n3\n*.*\n.*.\n4\n**.*\n**..\n5\n**...\n...**\n\nOutput\nCopy\n\n0\n2\n3\n5\n5\n"
        },
        {
            "problem": "F",
            "task": "F. Lenient Vertex Cover\ntime limit per test\n5 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a simple connected undirected graph, consisting of n\nvertices and m edges. The vertices are numbered from 1 to n\n\n.\n\nA vertex cover of a graph is a set of vertices such that each edge has at least one of its endpoints in the set.\n\nLet's call a lenient vertex cover such a vertex cover that at most one edge in it has both endpoints in the set.\n\nFind a lenient vertex cover of a graph or report that there is none. If there are multiple answers, then print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains two integers n\nand m (2≤n≤106; n−1≤m≤min(106,n⋅(n−1)2)\n\n) — the number of vertices and the number of edges of the graph.\n\nEach of the next m\nlines contains two integers v and u (1≤v,u≤n; v≠u\n\n) — the descriptions of the edges.\n\nFor each testcase, the graph is connected and doesn't have multiple edges. The sum of n\nover all testcases doesn't exceed 106. The sum of m over all testcases doesn't exceed 106\n\n.\nOutput\n\nFor each testcase, the first line should contain YES if a lenient vertex cover exists, and NO otherwise. If it exists, the second line should contain a binary string s\nof length n, where si=1 means that vertex i is in the vertex cover, and si=0 means that vertex i\n\nisn't.\n\nIf there are multiple answers, then print any of them.\nExamples\nInput\nCopy\n\n4\n6 5\n1 3\n2 4\n3 4\n3 5\n4 6\n4 6\n1 2\n2 3\n3 4\n1 4\n1 3\n2 4\n8 11\n1 3\n2 4\n3 5\n4 6\n5 7\n6 8\n1 2\n3 4\n5 6\n7 8\n7 2\n4 5\n1 2\n2 3\n3 4\n1 3\n2 4\n\nOutput\nCopy\n\nYES\n001100\nNO\nYES\n01100110\nYES\n0110\n\nInput\nCopy\n\n1\n10 15\n9 4\n3 4\n6 4\n1 2\n8 2\n8 3\n7 2\n9 5\n7 8\n5 10\n1 4\n2 10\n5 3\n5 7\n2 9\n\nOutput\nCopy\n\nYES\n0101100100\n\nInput\nCopy\n\n1\n10 19\n7 9\n5 3\n3 4\n1 6\n9 4\n1 4\n10 5\n7 1\n9 2\n8 3\n7 3\n10 9\n2 10\n9 8\n3 2\n1 5\n10 7\n9 5\n1 2\n\nOutput\nCopy\n\nYES\n1010000011\n\nNote\n\nHere are the graphs from the first example. The vertices in the lenient vertex covers are marked red.\n"
        }
    ],
    "/contest/1701": [
        {
            "problem": "A",
            "task": "A. Grass Field\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nThere is a field of size 2×2\n. Each cell of this field can either contain grass or be empty. The value ai,j is 1 if the cell (i,j) contains grass, or 0\n\notherwise.\n\nIn one move, you can choose one row and one column and cut all the grass in this row and this column. In other words, you choose the row x\nand the column y, then you cut the grass in all cells ax,i and all cells ai,y for all i from 1 to 2. After you cut the grass from a cell, it becomes empty (i. e. its value is replaced by 0\n\n).\n\nYour task is to find the minimum number of moves required to cut the grass in all non-empty cells of the field (i. e. make all ai,j\n\nzeros).\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤16) — the number of test cases. Then t\n\ntest cases follow.\n\nThe test case consists of two lines, each of these lines contains two integers. The j\n-th integer in the i-th row is ai,j. If ai,j=0 then the cell (i,j) is empty, and if ai,j=1 the cell (i,j)\n\ncontains grass.\nOutput\n\nFor each test case, print one integer — the minimum number of moves required to cut the grass in all non-empty cells of the field (i. e. make all ai,j\n\nzeros) in the corresponding test case.\nExample\nInput\nCopy\n\n3\n0 0\n0 0\n1 0\n0 1\n1 1\n1 1\n\nOutput\nCopy\n\n0\n1\n2\n"
        },
        {
            "problem": "B",
            "task": "B. Permutation\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nRecall that a permutation of length n\nis an array where each element from 1 to n\n\noccurs exactly once.\n\nFor a fixed positive integer d\n, let's define the cost of the permutation p of length n as the number of indices i (1≤i<n) such that pi⋅d=pi+1\n\n.\n\nFor example, if d=3\nand p=[5,2,6,7,1,3,4], then the cost of such a permutation is 2, because p2⋅3=p3 and p5⋅3=p6\n\n.\n\nYour task is the following one: for a given value n\n, find the permutation of length n and the value d with maximum possible cost (over all ways to choose the permutation and d\n\n). If there are multiple answers, then print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤500\n\n) — the number of test cases.\n\nThe single line of each test case contains a single integer n\n(2≤n≤2⋅105\n\n).\n\nThe sum of n\nover all test cases does not exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print the value d\nin the first line, and n\n\nintegers in the second line — the permutation itself. If there are multiple answers, then print any of them.\nExample\nInput\nCopy\n\n2\n2\n3\n\nOutput\nCopy\n\n2\n1 2\n3\n2 1 3\n"
        },
        {
            "problem": "C",
            "task": "C. Schedule Management\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere are n\nworkers and m tasks. The workers are numbered from 1 to n. Each task i has a value ai\n\n — the index of worker who is proficient in this task.\n\nEvery task should have a worker assigned to it. If a worker is proficient in the task, they complete it in 1\nhour. Otherwise, it takes them 2\n\nhours.\n\nThe workers work in parallel, independently of each other. Each worker can only work on one task at once.\n\nAssign the workers to all tasks in such a way that the tasks are completed as early as possible. The work starts at time 0\n\n. What's the minimum time all tasks can be completed by?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains two integers n\nand m (1≤n≤m≤2⋅105\n\n) — the number of workers and the number of tasks.\n\nThe second line contains m\nintegers a1,a2,…,am (1≤ai≤n) — the index of the worker proficient in the i\n\n-th task.\n\nThe sum of m\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the minimum time all tasks can be completed by.\nExample\nInput\nCopy\n\n4\n2 4\n1 2 1 2\n2 4\n1 1 1 1\n5 5\n5 1 3 2 4\n1 1\n1\n\nOutput\nCopy\n\n2\n3\n1\n1\n\nNote\n\nIn the first testcase, the first worker works on tasks 1\nand 3, and the second worker works on tasks 2 and 4. Since they both are proficient in the corresponding tasks, they take 1 hour on each. Both of them complete 2 tasks in 2 hours. Thus, all tasks are completed by 2\n\nhours.\n\nIn the second testcase, it's optimal to assign the first worker to tasks 1,2\nand 3 and the second worker to task 4. The first worker spends 3 hours, the second worker spends 2\n\nhours (since they are not proficient in the taken task).\n\nIn the third example, each worker can be assigned to the task they are proficient at. Thus, each of them complete their task in 1\nhour."
        },
        {
            "problem": "D",
            "task": "D. Permutation Restoration\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp had a permutation a\nof n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n\n\noccurs exactly once).\n\nThen Monocarp calculated an array of integers b\nof size n, where bi=⌊iai⌋. For example, if the permutation a is [2,1,4,3], then the array b is equal to [⌊12⌋,⌊21⌋,⌊34⌋,⌊43⌋]=[0,2,0,1]\n\n.\n\nUnfortunately, the Monocarp has lost his permutation, so he wants to restore it. Your task is to find a permutation a\nthat corresponds to the given array b\n\n. If there are multiple possible permutations, then print any of them. The tests are constructed in such a way that least one suitable permutation exists.\nInput\n\nThe first line contains a single integer t\n(1≤t≤105\n\n) — number of test cases.\n\nThe first line of each test case contains a single integer n\n(1≤n≤5⋅105\n\n).\n\nThe second line contains n\nintegers b1,b2,…,bn (0≤bi≤n\n\n).\n\nAdditional constrains on the input:\n\n    the sum of n\n\nover test cases does not exceed 5⋅105\n;\nthere exists at least one permutation a\nthat would yield this array b\n\n    . \n\nOutput\n\nFor each test case, print n\nintegers — a permutation a that corresponds to the given array b\n\n. If there are multiple possible permutations, then print any of them.\nExample\nInput\nCopy\n\n4\n4\n0 2 0 1\n2\n1 1\n5\n0 0 1 4 1\n3\n0 1 3\n\nOutput\nCopy\n\n2 1 4 3 \n1 2 \n3 4 2 1 5 \n3 2 1 \n"
        },
        {
            "problem": "E",
            "task": "E. Text Editor\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou wanted to write a text t\nconsisting of m lowercase Latin letters. But instead, you have written a text s consisting of n lowercase Latin letters, and now you want to fix it by obtaining the text t from the text s\n\n.\n\nInitially, the cursor of your text editor is at the end of the text s\n\n(after its last character). In one move, you can do one of the following actions:\n\n    press the \"left\" button, so the cursor is moved to the left by one position (or does nothing if it is pointing at the beginning of the text, i. e. before its first character);\n    press the \"right\" button, so the cursor is moved to the right by one position (or does nothing if it is pointing at the end of the text, i. e. after its last character);\n    press the \"home\" button, so the cursor is moved to the beginning of the text (before the first character of the text);\n    press the \"end\" button, so the cursor is moved to the end of the text (after the last character of the text);\n    press the \"backspace\" button, so the character before the cursor is removed from the text (if there is no such character, nothing happens). \n\nYour task is to calculate the minimum number of moves required to obtain the text t\nfrom the text s using the given set of actions, or determine it is impossible to obtain the text t from the text s\n\n.\n\nYou have to answer T\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer T\n(1≤T≤5000) — the number of test cases. Then T\n\ntest cases follow.\n\nThe first line of the test case contains two integers n\nand m (1≤m≤n≤5000) — the length of s and the length of t\n\n, respectively.\n\nThe second line of the test case contains the string s\nconsisting of n\n\nlowercase Latin letters.\n\nThe third line of the test case contains the string t\nconsisting of m\n\nlowercase Latin letters.\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 5000 (∑n≤5000\n\n).\nOutput\n\nFor each test case, print one integer — the minimum number of moves required to obtain the text t\nfrom the text s using the given set of actions, or -1 if it is impossible to obtain the text t from the text s\n\nin the given test case.\nExample\nInput\nCopy\n\n6\n9 4\naaaaaaaaa\naaaa\n7 3\nabacaba\naaa\n5 4\naabcd\nabcd\n4 2\nabba\nbb\n6 4\nbaraka\nbaka\n8 7\nquestion\nproblem\n\nOutput\nCopy\n\n5\n6\n3\n4\n4\n-1\n"
        },
        {
            "problem": "F",
            "task": "F. Points\ntime limit per test\n6.5 seconds\nmemory limit per test\n512 megabytes\n\nA triple of points i\n, j and k on a coordinate line is called beautiful if i<j<k and k−i≤d\n\n.\n\nYou are given a set of points on a coordinate line, initially empty. You have to process queries of three types:\n\n    add a point;\n    remove a point;\n    calculate the number of beautiful triples consisting of points belonging to the set. \n\nInput\n\nThe first line contains two integers q\nand d (1≤q,d≤2⋅105\n\n) — the number of queries and the parameter for defining if a triple is beautiful, respectively.\n\nThe second line contains q\nintegers a1,a2,…,aq (1≤ai≤2⋅105) denoting the queries. The integer ai denotes the i\n\n-th query in the following way:\n\n    if the point ai\n\n    belongs to the set, remove it; otherwise, add it;\n    after adding or removing the point, print the number of beautiful triples. \n\nOutput\n\nFor each query, print one integer — the number of beautiful triples after processing the respective query.\nExample\nInput\nCopy\n\n7 5\n8 5 3 2 1 5 6\n\nOutput\nCopy\n\n0\n0\n1\n2\n5\n1\n5\n"
        }
    ],
    "/contest/1661": [
        {
            "problem": "A",
            "task": "A. Array Balancing\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given two arrays of length n\n: a1,a2,…,an and b1,b2,…,bn\n\n.\n\nYou can perform the following operation any number of times:\n\n    Choose integer index i\n\n(1≤i≤n\n);\nSwap ai\nand bi\n\n    . \n\nWhat is the minimum possible sum |a1−a2|+|a2−a3|+⋯+|an−1−an|\n+ |b1−b2|+|b2−b3|+⋯+|bn−1−bn| (in other words, ∑i=1n−1(|ai−ai+1|+|bi−bi+1|)\n\n) you can achieve after performing several (possibly, zero) operations?\nInput\n\nThe first line contains a single integer t\n(1≤t≤4000) — the number of test cases. Then, t\n\ntest cases follow.\n\nThe first line of each test case contains the single integer n\n(2≤n≤25) — the length of arrays a and b\n\n.\n\nThe second line of each test case contains n\nintegers a1,a2,…,an (1≤ai≤109) — the array a\n\n.\n\nThe third line of each test case contains n\nintegers b1,b2,…,bn (1≤bi≤109) — the array b\n\n.\nOutput\n\nFor each test case, print one integer — the minimum possible sum ∑i=1n−1(|ai−ai+1|+|bi−bi+1|)\n\n.\nExample\nInput\nCopy\n\n3\n4\n3 3 10 10\n10 10 3 3\n5\n1 2 3 4 5\n6 7 8 9 10\n6\n72 101 108 108 111 44\n10 87 111 114 108 100\n\nOutput\nCopy\n\n0\n8\n218\n\nNote\n\nIn the first test case, we can, for example, swap a3\nwith b3 and a4 with b4. We'll get arrays a=[3,3,3,3] and b=[10,10,10,10] with sum 3⋅|3−3|+3⋅|10−10|=0\n\n.\n\nIn the second test case, arrays already have minimum sum (described above) equal to |1−2|+⋯+|4−5|+|6−7|+⋯+|9−10|\n=4+4=8\n\n.\n\nIn the third test case, we can, for example, swap a5\nand b5."
        },
        {
            "problem": "B",
            "task": "B. Getting Zero\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nSuppose you have an integer v\n\n. In one operation, you can:\n\n    either set v=(v+1)mod32768\n\nor set v=(2⋅v)mod32768\n\n    . \n\nYou are given n\nintegers a1,a2,…,an. What is the minimum number of operations you need to make each ai equal to 0\n\n?\nInput\n\nThe first line contains the single integer n\n(1≤n≤32768\n\n) — the number of integers.\n\nThe second line contains n\nintegers a1,a2,…,an (0≤ai<32768\n\n).\nOutput\n\nPrint n\nintegers. The i-th integer should be equal to the minimum number of operations required to make ai equal to 0\n\n.\nExample\nInput\nCopy\n\n4\n19 32764 10240 49\n\nOutput\nCopy\n\n14 4 4 15 \n\nNote\n\nLet's consider each ai\n\n:\n\n    a1=19\n\n. You can, firstly, increase it by one to get 20 and then multiply it by two 13 times. You'll get 0 in 1+13=14\nsteps.\na2=32764\n. You can increase it by one 4 times: 32764→32765→32766→32767→0\n.\na3=10240\n. You can multiply it by two 4 times: 10240→20480→8192→16384→0\n.\na4=49\n. You can multiply it by two 15 times."
        },
        {
            "problem": "C",
            "task": "C. Water the Trees\ntime limit per test\n3 seconds\nmemory limit per test\n256 megabytes\n\nThere are n\ntrees in a park, numbered from 1 to n. The initial height of the i-th tree is hi\n\n.\n\nYou want to water these trees, so they all grow to the same height.\n\nThe watering process goes as follows. You start watering trees at day 1\n. During the j\n\n-th day you can:\n\n    Choose a tree and water it. If the day is odd (e.g. 1,3,5,7,…\n\n), then the height of the tree increases by 1. If the day is even (e.g. 2,4,6,8,…), then the height of the tree increases by 2\n\n    .\n    Or skip a day without watering any tree. \n\nNote that you can't water more than one tree in a day.\n\nYour task is to determine the minimum number of days required to water the trees so they grow to the same height.\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤2⋅104\n\n) — the number of test cases.\n\nThe first line of the test case contains one integer n\n(1≤n≤3⋅105\n\n) — the number of trees.\n\nThe second line of the test case contains n\nintegers h1,h2,…,hn (1≤hi≤109), where hi is the height of the i\n\n-th tree.\n\nIt is guaranteed that the sum of n\nover all test cases does not exceed 3⋅105 (∑n≤3⋅105\n\n).\nOutput\n\nFor each test case, print one integer — the minimum number of days required to water the trees, so they grow to the same height.\nExample\nInput\nCopy\n\n3\n3\n1 2 4\n5\n4 4 3 5 5\n7\n2 5 4 8 3 7 4\n\nOutput\nCopy\n\n4\n3\n16\n\nNote\n\nConsider the first test case of the example. The initial state of the trees is [1,2,4]\n\n.\n\n    During the first day, let's water the first tree, so the sequence of heights becomes [2,2,4]\n\n;\nduring the second day, let's water the second tree, so the sequence of heights becomes [2,4,4]\n;\nlet's skip the third day;\nduring the fourth day, let's water the first tree, so the sequence of heights becomes [4,4,4]\n\n    . \n\nThus, the answer is 4\n."
        },
        {
            "problem": "D",
            "task": "D. Progressions Covering\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given two arrays: an array a\nconsisting of n zeros and an array b consisting of n\n\nintegers.\n\nYou can apply the following operation to the array a\nan arbitrary number of times: choose some subsegment of a of length k and add the arithmetic progression 1,2,…,k to this subsegment — i. e. add 1 to the first element of the subsegment, 2 to the second element, and so on. The chosen subsegment should be inside the borders of the array a (i.e., if the left border of the chosen subsegment is l, then the condition 1≤l≤l+k−1≤n should be satisfied). Note that the progression added is always 1,2,…,k but not the k,k−1,…,1 or anything else (i.e., the leftmost element of the subsegment always increases by 1, the second element always increases by 2\n\nand so on).\n\nYour task is to find the minimum possible number of operations required to satisfy the condition ai≥bi\nfor each i from 1 to n. Note that the condition ai≥bi\n\nshould be satisfied for all elements at once.\nInput\n\nThe first line of the input contains two integers n\nand k (1≤k≤n≤3⋅105\n\n) — the number of elements in both arrays and the length of the subsegment, respectively.\n\nThe second line of the input contains n\nintegers b1,b2,…,bn (1≤bi≤1012), where bi is the i-th element of the array b\n\n.\nOutput\n\nPrint one integer — the minimum possible number of operations required to satisfy the condition ai≥bi\nfor each i from 1 to n\n\n.\nExamples\nInput\nCopy\n\n3 3\n5 4 6\n\nOutput\nCopy\n\n5\n\nInput\nCopy\n\n6 3\n1 2 3 2 2 3\n\nOutput\nCopy\n\n3\n\nInput\nCopy\n\n6 3\n1 2 4 1 2 3\n\nOutput\nCopy\n\n3\n\nInput\nCopy\n\n7 3\n50 17 81 25 42 39 96\n\nOutput\nCopy\n\n92\n\nNote\n\nConsider the first example. In this test, we don't really have any choice, so we need to add at least five progressions to make the first element equals 5\n. The array a becomes [5,10,15]\n\n.\n\nConsider the second example. In this test, let's add one progression on the segment [1;3]\nand two progressions on the segment [4;6]. Then, the array a becomes [1,2,3,2,4,6]."
        },
        {
            "problem": "E",
            "task": "E. Narrow Components\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a matrix a\n, consisting of 3 rows and n\n\ncolumns. Each cell of the matrix is either free or taken.\n\nA free cell y\nis reachable from a free cell x\n\nif at least one of these conditions hold:\n\n    x\n\nand y\nshare a side;\nthere exists a free cell z\nsuch that z is reachable from x and y is reachable from z\n\n    . \n\nA connected component is a set of free cells of the matrix such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\n\nYou are asked q\n\nqueries about the matrix. Each query is the following:\n\n    l\n\nr — count the number of connected components of the matrix, consisting of columns from l to r of the matrix a\n\n    , inclusive. \n\nPrint the answers to all queries.\nInput\n\nThe first line contains an integer n\n(1≤n≤5⋅105) — the number of columns of matrix a\n\n.\n\nThe i\n-th of the next three lines contains a description of the i-th row of the matrix a — a string, consisting of n characters. Each character is either 1 (denoting a free cell) or 0\n\n(denoting a taken cell).\n\nThe next line contains an integer q\n(1≤q≤3⋅105\n\n) — the number of queries.\n\nThe j\n-th of the next q lines contains two integers lj and rj (1≤lj≤rj≤n) — the description of the j\n\n-th query.\nOutput\n\nPrint q\nintegers — the j-th value should be equal to the number of the connected components of the matrix, consisting of columns from lj to rj of the matrix a\n\n, inclusive.\nExample\nInput\nCopy\n\n12\n100101011101\n110110010110\n010001011101\n8\n1 12\n1 1\n1 2\n9 9\n8 11\n9 12\n11 12\n4 6\n\nOutput\nCopy\n\n7\n1\n1\n2\n1\n3\n3\n3\n"
        },
        {
            "problem": "F",
            "task": "F. Teleporters\ntime limit per test\n7 seconds\nmemory limit per test\n512 megabytes\n\nThere are n+1\nteleporters on a straight line, located in points 0, a1, a2, a3, ..., an. It's possible to teleport from point x to point y if there are teleporters in both of those points, and it costs (x−y)2\n\nenergy.\n\nYou want to install some additional teleporters so that it is possible to get from the point 0\nto the point an (possibly through some other teleporters) spending no more than m\n\nenergy in total. Each teleporter you install must be located in an integer point.\n\nWhat is the minimum number of teleporters you have to install?\nInput\n\nThe first line contains one integer n\n(1≤n≤2⋅105\n\n).\n\nThe second line contains n\nintegers a1,a2,…,an (1≤a1<a2<a3<⋯<an≤109\n\n).\n\nThe third line contains one integer m\n(an≤m≤1018\n\n).\nOutput\n\nPrint one integer — the minimum number of teleporters you have to install so that it is possible to get from 0\nto an spending at most m\n\nenergy. It can be shown that it's always possible under the constraints from the input format.\nExamples\nInput\nCopy\n\n2\n1 5\n7\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n2\n1 5\n6\n\nOutput\nCopy\n\n3\n\nInput\nCopy\n\n1\n5\n5\n\nOutput\nCopy\n\n4\n\nInput\nCopy\n\n1\n1000000000\n1000000043\n\nOutput\nCopy\n\n999999978\n"
        }
    ],
    "/contest/1626": [
        {
            "problem": "A",
            "task": "A. Equidistant Letters\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a string s\n\n, consisting of lowercase Latin letters. Every letter appears in it no more than twice.\n\nYour task is to rearrange the letters in the string in such a way that for each pair of letters that appear exactly twice, the distance between the letters in the pair is the same. You are not allowed to add or remove letters.\n\nIt can be shown that the answer always exists. If there are multiple answers, print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤103\n\n) — the number of testcases.\n\nEach testcase consists of a non-empty string s\n, consisting of lowercase Latin letters. Every letter appears in the string no more than twice. The length of the string doesn't exceed 52\n\n.\nOutput\n\nFor each testcase, print a single string. Every letter should appear in it the same number of times as it appears in string s\n\n. For each pair of letters that appear exactly twice, the distance between the letters in the pair should be the same.\n\nIf there are multiple answers, print any of them.\nExample\nInput\nCopy\n\n3\noelhl\nabcdcba\nac\n\nOutput\nCopy\n\nhello\nababcdc\nac\n\nNote\n\nIn the first testcase of the example, the only letter that appears exactly twice is letter 'l'. You can rearrange the letters arbitrarily, since there are no distances to compare.\n\nIn the second testcase of the example, the letters that appear exactly twice are 'a', 'b' and 'c'. Initially, letters 'a' are distance 6\napart, letters 'b' are distance 4 apart and letters 'c' are distance 2 apart. They are not the same, so we have to rearrange the letters. After rearrangement, letters 'a' are distance 2 apart, letters 'b' are distance 2 apart and letters 'c' are distance 2\n\napart. They are all the same, so the answer is valid.\n\nIn the third testcase of the example, there are no letters that appear exactly twice. Thus, any rearrangement is valid. Including not changing the string at all."
        },
        {
            "problem": "B",
            "task": "B. Minor Reduction\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a decimal representation of an integer x\n\nwithout leading zeros.\n\nYou have to perform the following reduction on it exactly once: take two neighboring digits in x\nand replace them with their sum without leading zeros (if the sum is 0, it's represented as a single 0\n\n).\n\nFor example, if x=10057\n\n, the possible reductions are:\n\n    choose the first and the second digits 1\n\nand 0, replace them with 1+0=1; the result is 1057\n;\nchoose the second and the third digits 0\nand 0, replace them with 0+0=0; the result is also 1057\n;\nchoose the third and the fourth digits 0\nand 5, replace them with 0+5=5; the result is still 1057\n;\nchoose the fourth and the fifth digits 5\nand 7, replace them with 5+7=12; the result is 10012\n\n    . \n\nWhat's the largest number that can be obtained?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nEach testcase consists of a single integer x\n(10≤x<10200000). x\n\ndoesn't contain leading zeros.\n\nThe total length of the decimal representations of x\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.\nExample\nInput\nCopy\n\n2\n10057\n90\n\nOutput\nCopy\n\n10012\n9\n\nNote\n\nThe first testcase of the example is already explained in the statement.\n\nIn the second testcase, there is only one possible reduction: the first and the second digits."
        },
        {
            "problem": "C",
            "task": "C. Monsters And Spells\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp is playing a computer game once again. He is a wizard apprentice, who only knows a single spell. Luckily, this spell can damage the monsters.\n\nThe level he's currently on contains n\nmonsters. The i-th of them appears ki seconds after the start of the level and has hi health points. As an additional constraint, hi≤ki for all 1≤i≤n. All ki\n\nare different.\n\nMonocarp can cast the spell at moments which are positive integer amounts of second after the start of the level: 1,2,3,…\nThe damage of the spell is calculated as follows. If he didn't cast the spell at the previous second, the damage is 1. Otherwise, let the damage at the previous second be x. Then he can choose the damage to be either x+1 or 1. A spell uses mana: casting a spell with damage x uses x\n\nmana. Mana doesn't regenerate.\n\nTo kill the i\n-th monster, Monocarp has to cast a spell with damage at least hi at the exact moment the monster appears, which is ki\n\n.\n\nNote that Monocarp can cast the spell even when there is no monster at the current second.\n\nThe mana amount required to cast the spells is the sum of mana usages for all cast spells. Calculate the least amount of mana required for Monocarp to kill all monsters.\n\nIt can be shown that it's always possible to kill all monsters under the constraints of the problem.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of the testcase contains a single integer n\n(1≤n≤100\n\n) — the number of monsters in the level.\n\nThe second line of the testcase contains n\nintegers k1<k2<⋯<kn (1≤ki≤109) — the number of second from the start the i-th monster appears at. All ki are different, ki\n\nare provided in the increasing order.\n\nThe third line of the testcase contains n\nintegers h1,h2,…,hn (1≤hi≤ki≤109) — the health of the i\n\n-th monster.\n\nThe sum of n\nover all testcases doesn't exceed 104\n\n.\nOutput\n\nFor each testcase, print a single integer — the least amount of mana required for Monocarp to kill all monsters.\nExample\nInput\nCopy\n\n3\n1\n6\n4\n2\n4 5\n2 2\n3\n5 7 9\n2 1 2\n\nOutput\nCopy\n\n10\n6\n7\n\nNote\n\nIn the first testcase of the example, Monocarp can cast spells 3,4,5\nand 6 seconds from the start with damages 1,2,3 and 4, respectively. The damage dealt at 6 seconds is 4\n\n, which is indeed greater than or equal to the health of the monster that appears.\n\nIn the second testcase of the example, Monocarp can cast spells 3,4\nand 5 seconds from the start with damages 1,2 and 3\n\n, respectively.\n\nIn the third testcase of the example, Monocarp can cast spells 4,5,7,8\nand 9 seconds from the start with damages 1,2,1,1 and 2, respectively."
        },
        {
            "problem": "D",
            "task": "D. Martial Arts Tournament\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp is planning to host a martial arts tournament. There will be three divisions based on weight: lightweight, middleweight and heavyweight. The winner of each division will be determined by a single elimination system.\n\nIn particular, that implies that the number of participants in each division should be a power of two. Additionally, each division should have a non-zero amount of participants.\n\nn\nparticipants have registered for the tournament so far, the i-th of them weighs ai. To split participants into divisions, Monocarp is going to establish two integer weight boundaries x and y (x<y\n\n).\n\nAll participants who weigh strictly less than x\nwill be considered lightweight. All participants who weigh greater or equal to y\n\nwill be considered heavyweight. The remaining participants will be considered middleweight.\n\nIt's possible that the distribution doesn't make the number of participants in each division a power of two. It can also lead to empty divisions. To fix the issues, Monocarp can invite an arbitrary number of participants to each division.\n\nNote that Monocarp can't kick out any of the n\n\nparticipants who have already registered for the tournament.\n\nHowever, he wants to invite as little extra participants as possible. Help Monocarp to choose x\nand y\n\nin such a way that the total amount of extra participants required is as small as possible. Output that amount.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(1≤n≤2⋅105\n\n) — the number of the registered participants.\n\nThe second line of each testcase contains n\nintegers a1,a2,…,an (1≤ai≤n\n\n) — the weights of the registered participants.\n\nThe sum of n\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the smallest number of extra participants Monocarp is required to invite after he chooses the weight boundaries x\nand y\n\n.\nExample\nInput\nCopy\n\n4\n4\n3 1 2 1\n1\n1\n6\n2 2 2 1 1 1\n8\n6 3 6 3 6 3 6 6\n\nOutput\nCopy\n\n0\n2\n3\n2\n\nNote\n\nIn the first testcase of the example, Monocarp can choose x=2\nand y=3. Lightweight, middleweight and heavyweight divisions will have 2, 1 and 1\n\nparticipants, respectively. They all are powers of two, so no extra participants are required.\n\nIn the second testcase of the example, regardless of the choice of x\nand y, one division will have 1 participant, the rest will have 0. Thus, Monocarp will have to invite 1\n\nparticipant into both of the remaining divisions.\n\nIn the third testcase of the example, Monocarp can choose x=1\nand y=2. Lightweight, middleweight and heavyweight divisions will have 0, 3 and 3\n\nparticipants, respectively. So an extra participant is needed in each division.\n\nIn the fourth testcase of the example, Monocarp can choose x=8\nand y=9. Lightweight, middleweight and heavyweight divisions will have 8, 0 and 0 participants, respectively. Middleweight and heavyweight division need an extra participant each."
        },
        {
            "problem": "E",
            "task": "E. Black and White Tree\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a tree consisting of n\n\nvertices. Some of the vertices (at least two) are black, all the other vertices are white.\n\nYou place a chip on one of the vertices of the tree, and then perform the following operations:\n\n    let the current vertex where the chip is located is x\n\n. You choose a black vertex y, and then move the chip along the first edge on the simple path from x to y\n\n    . \n\nYou are not allowed to choose the same black vertex y\n\nin two operations in a row (i. e., for every two consecutive operations, the chosen black vertex should be different).\n\nYou end your operations when the chip moves to the black vertex (if it is initially placed in a black vertex, you don't perform the operations at all), or when the number of performed operations exceeds 100500\n\n.\n\nFor every vertex i\n, you have to determine if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex, if the chip is initially placed on the vertex i\n\n.\nInput\n\nThe first line contains one integer n\n(3≤n≤3⋅105\n\n) — the number of vertices in the tree.\n\nThe second line contains n\nintegers c1,c2,…,cn (0≤ci≤1), where ci=0 means that the i-th vertex is white, and ci=1 means that the i-th vertex is black. At least two values of ci are equal to 1\n\n.\n\nThen n−1\nlines follow, each of them contains two integers ui and vi (1≤ui,vi≤n; ui≠vi\n\n) — the endpoints of some edge. These edges form a tree.\nOutput\n\nPrint n\nintegers. The i-th integer should be equal to 1 if there exists a (possibly empty) sequence of operations that moves the chip to some black vertex if it is placed on the vertex i, and 0\n\nif no such sequence of operations exists.\nExample\nInput\nCopy\n\n8\n0 1 0 0 0 0 1 0\n8 6\n2 5\n7 8\n6 5\n4 5\n6 1\n7 3\n\nOutput\nCopy\n\n0 1 1 1 1 0 1 1 \n"
        },
        {
            "problem": "F",
            "task": "F. A Random Code Problem\ntime limit per test\n3 seconds\nmemory limit per test\n512 megabytes\n\nYou are given an integer array a0,a1,…,an−1\n, and an integer k\n\n. You perform the following code with it:\n\nlong long ans = 0; // create a 64-bit signed variable which is initially equal to 0\nfor(int i = 1; i <= k; i++)\n{\n  int idx = rnd.next(0, n - 1); // generate a random integer between 0 and n - 1, both inclusive\n                                // each integer from 0 to n - 1 has the same probability of being chosen\n  ans += a[idx];\n  a[idx] -= (a[idx] % i);\n}\n\nYour task is to calculate the expected value of the variable ans after performing this code.\n\nNote that the input is generated according to special rules (see the input format section).\nInput\n\nThe only line contains six integers n\n, a0, x, y, k and M (1≤n≤107; 1≤a0,x,y<M≤998244353; 1≤k≤17\n\n).\n\nThe array a\n\nin the input is constructed as follows:\n\n    a0\n\nis given in the input;\nfor every i\nfrom 1 to n−1, the value of ai can be calculated as ai=(ai−1⋅x+y)modM\n\n    . \n\nOutput\n\nLet the expected value of the variable ans after performing the code be E\n. It can be shown that E⋅nk is an integer. You have to output this integer modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n3 10 3 5 13 88\n\nOutput\nCopy\n\n382842030\n\nInput\nCopy\n\n2 15363 270880 34698 17 2357023\n\nOutput\nCopy\n\n319392398\n\nNote\n\nThe array in the first example test is [10,35,22]\n. In the second example, it is [15363,1418543]."
        }
    ],
    "/contest/1721": [
        {
            "problem": "A",
            "task": "A. Image\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou have an image file of size 2×2\n, consisting of 4 pixels. Each pixel can have one of 26\n\ndifferent colors, denoted by lowercase Latin letters.\n\nYou want to recolor some of the pixels of the image so that all 4\n\npixels have the same color. In one move, you can choose no more than two pixels of the same color and paint them into some other color (if you choose two pixels, both should be painted into the same color).\n\nWhat is the minimum number of moves you have to make in order to fulfill your goal?\nInput\n\nThe first line contains one integer t\n(1≤t≤1000\n\n) — the number of test cases.\n\nEach test case consists of two lines. Each of these lines contains two lowercase letters of Latin alphabet without any separators, denoting a row of pixels in the image.\nOutput\n\nFor each test case, print one integer — the minimum number of moves you have to make so that all 4\n\npixels of the image have the same color.\nExample\nInput\nCopy\n\n5\nrb\nbr\ncc\nwb\naa\naa\nab\ncd\nyy\nxx\n\nOutput\nCopy\n\n1\n2\n0\n3\n1\n\nNote\n\nLet's analyze the test cases of the example.\n\nIn the first test case, you can paint the bottom left pixel and the top right pixel (which share the same color) into the color r, so all pixels have this color.\n\nIn the second test case, two moves are enough:\n\n    paint both top pixels, which have the same color c, into the color b;\n    paint the bottom left pixel into the color b. \n\nIn the third test case, all pixels already have the same color.\n\nIn the fourth test case, you may leave any of the pixels unchanged, and paint all three other pixels into the color of that pixel in three moves.\n\nIn the fifth test case, you can paint both top pixels into the color x."
        },
        {
            "problem": "B",
            "task": "B. Deadly Laser\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThe robot is placed in the top left corner of a grid, consisting of n\nrows and m columns, in a cell (1,1)\n\n.\n\nIn one step, it can move into a cell, adjacent by a side to the current one:\n\n    (x,y)→(x,y+1)\n\n;\n(x,y)→(x+1,y)\n;\n(x,y)→(x,y−1)\n;\n(x,y)→(x−1,y)\n\n    . \n\nThe robot can't move outside the grid.\n\nThe cell (sx,sy)\ncontains a deadly laser. If the robot comes into some cell that has distance less than or equal to d to the laser, it gets evaporated. The distance between two cells (x1,y1) and (x2,y2) is |x1−x2|+|y1−y2|\n\n.\n\nPrint the smallest number of steps that the robot can take to reach the cell (n,m)\nwithout getting evaporated or moving outside the grid. If it's not possible to reach the cell (n,m)\n\n, print -1.\n\nThe laser is neither in the starting cell, nor in the ending cell. The starting cell always has distance greater than d\n\nto the laser.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe only line of each testcase contains five integers n,m,sx,sy,d\n(2≤n,m≤1000; 1≤sx≤n; 1≤sy≤m; 0≤d≤n+m\n\n) — the size of the grid, the cell that contains the laser and the evaporating distance of the laser.\n\nThe laser is neither in the starting cell, nor in the ending cell ((sx,sy)≠(1,1)\nand (sx,sy)≠(n,m)). The starting cell (1,1) always has distance greater than d to the laser (|sx−1|+|sy−1|>d\n\n).\nOutput\n\nFor each testcase, print a single integer. If it's possible to reach the cell (n,m)\nfrom (1,1)\n\nwithout getting evaporated or moving outside the grid, then print the smallest amount of steps it can take the robot to reach it. Otherwise, print -1.\nExample\nInput\nCopy\n\n3\n2 3 1 3 0\n2 3 1 3 1\n5 5 3 4 1\n\nOutput\nCopy\n\n3\n-1\n8\n"
        },
        {
            "problem": "C",
            "task": "C. Min-Max Array Transformation\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given an array a1,a2,…,an\n, which is sorted in non-descending order. You decided to perform the following steps to create array b1,b2,…,bn\n\n:\n\n    Create an array d\n\nconsisting of n\narbitrary non-negative integers.\nSet bi=ai+di\nfor each bi\n.\nSort the array b\n\n    in non-descending order. \n\nYou are given the resulting array b\n. For each index i, calculate what is the minimum and maximum possible value of di you can choose in order to get the given array b\n\n.\n\nNote that the minimum (maximum) di\n-s are independent of each other, i. e. they can be obtained from different possible arrays d\n\n.\nInput\n\nThe first line contains the single integer t\n(1≤t≤104\n\n) — the number of test cases.\n\nThe first line of each test case contains a single integer n\n(1≤n≤2⋅105) — the length of arrays a, b and d\n\n.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤109; ai≤ai+1) — the array a\n\nin non-descending order.\n\nThe third line contains n\nintegers b1,b2,…,bn (1≤bi≤109; bi≤bi+1) — the array b\n\nin non-descending order.\n\nAdditional constraints on the input:\n\n    there is at least one way to obtain the array b\n\nfrom the a by choosing an array d\nconsisting of non-negative integers;\nthe sum of n\ndoesn't exceed 2⋅105\n\n    . \n\nOutput\n\nFor each test case, print two lines. In the first line, print n\nintegers dmin1,dmin2,…,dminn, where dmini is the minimum possible value you can add to ai\n\n.\n\nSecondly, print n\nintegers dmax1,dmax2,…,dmaxn, where dmaxi is the maximum possible value you can add to ai\n\n.\n\nAll dmini\nand dmaxi values are independent of each other. In other words, for each i, dmini is just the minimum value among all possible values of di\n\n.\nExample\nInput\nCopy\n\n4\n3\n2 3 5\n7 11 13\n1\n1000\n5000\n4\n1 2 3 4\n1 2 3 4\n4\n10 20 30 40\n22 33 33 55\n\nOutput\nCopy\n\n5 4 2\n11 10 8\n4000\n4000\n0 0 0 0\n0 0 0 0\n12 2 3 15\n23 13 3 15\n\nNote\n\nIn the first test case, in order to get dmin1=5\n, we can choose, for example, d=[5,10,6]. Then b = [2+5,3+10,5+6] = [7,13,11] = [7,11,13]\n\n.\n\nFor dmin2=4\n, we can choose d = [9,4,8]. Then b = [2+9,3+4,5+8] = [11,7,13] = [7,11,13]."
        },
        {
            "problem": "D",
            "task": "D. Maximum AND\ntime limit per test\n3 seconds\nmemory limit per test\n256 megabytes\n\nYou are given two arrays a\nand b, consisting of n\n\nintegers each.\n\nLet's define a function f(a,b)\n\nas follows:\n\n    let's define an array c\n\nof size n, where ci=ai⊕bi (⊕\ndenotes bitwise XOR);\nthe value of the function is c1&c2&⋯&cn\n(i.e. bitwise AND of the entire array c\n\n    ). \n\nFind the maximum value of the function f(a,b)\nif you can reorder the array b\n\nin an arbitrary way (leaving the initial order is also an option).\nInput\n\nThe first line contains one integer t\n(1≤t≤104\n\n) — the number of test cases.\n\nThe first line of each test case contains one integer n\n(1≤n≤105) — the size of arrays a and b\n\n.\n\nThe second line contains n\nintegers a1,a2,…,an (0≤ai<230\n\n).\n\nThe third line contains n\nintegers b1,b2,…,bn (0≤bi<230\n\n).\n\nThe sum of n\nover all test cases does not exceed 105\n\n.\nOutput\n\nFor each test case print one integer — the maximum value of the function f(a,b)\nif you can reorder the array b\n\nin an arbitrary way.\nExample\nInput\nCopy\n\n3\n5\n1 0 0 3 3\n2 3 2 1 0\n3\n1 1 1\n0 0 3\n8\n0 1 2 3 4 5 6 7\n7 6 5 4 3 2 1 0\n\nOutput\nCopy\n\n2\n0\n7\n"
        },
        {
            "problem": "E",
            "task": "E. Prefix Function Queries\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a string s\n\n, consisting of lowercase Latin letters.\n\nYou are asked q\nqueries about it: given another string t\n\n, consisting of lowercase Latin letters, perform the following steps:\n\n    concatenate s\n\nand t\n;\ncalculate the prefix function of the resulting string s+t\n;\nprint the values of the prefix function on positions |s|+1,|s|+2,…,|s|+|t|\n(|s| and |t| denote the lengths of strings s and t\n, respectively);\nrevert the string back to s\n\n    . \n\nThe prefix function of a string a\nis a sequence p1,p2,…,p|a|, where pi is the maximum value of k such that k<i and a[1..k]=a[i−k+1..i] (a[l..r] denotes a contiguous substring of a string a from a position l to a position r, inclusive). In other words, it's the longest proper prefix of the string a[1..i]\n\nthat is equal to its suffix of the same length.\nInput\n\nThe first line contains a non-empty string s\n(1≤|s|≤106\n\n), consisting of lowercase Latin letters.\n\nThe second line contains a single integer q\n(1≤q≤105\n\n) — the number of queries.\n\nEach of the next q\nlines contains a query: a non-empty string t (1≤|t|≤10\n\n), consisting of lowercase Latin letters.\nOutput\n\nFor each query, print the values of the prefix function of a string s+t\non positions |s|+1,|s|+2,…,|s|+|t|\n\n.\nExamples\nInput\nCopy\n\naba\n6\ncaba\naba\nbababa\naaaa\nb\nforces\n\nOutput\nCopy\n\n0 1 2 3 \n1 2 3 \n2 3 4 5 6 7 \n1 1 1 1 \n2 \n0 0 0 0 0 0 \n\nInput\nCopy\n\naacba\n4\naaca\ncbbb\naab\nccaca\n\nOutput\nCopy\n\n2 2 3 1 \n0 0 0 0 \n2 2 0 \n0 0 1 0 1 \n"
        },
        {
            "problem": "F",
            "task": "F. Matching Reduction\ntime limit per test\n8 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a bipartite graph with n1\nvertices in the first part, n2 vertices in the second part, and m\n\nedges. The maximum matching in this graph is the maximum possible (by size) subset of edges of this graph such that no vertex is incident to more than one chosen edge.\n\nYou have to process two types of queries to this graph:\n\n    1\n\n— remove the minimum possible number of vertices from this graph so that the size of the maximum matching gets reduced exactly by 1\n, and print the vertices that you have removed. Then, find any maximum matching in this graph and print the sum of indices of edges belonging to this matching;\n2\n— query of this type will be asked only after a query of type 1\n\n    . As the answer to this query, you have to print the edges forming the maximum matching you have chosen in the previous query. \n\nNote that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions fflush in C++ and BufferedWriter.flush in Java languages after each writing in your program.\nInput\n\nThe first line contains four integers n1\n, n2, m and q (1≤n1,n2≤2⋅105; 1≤m≤min(n1⋅n2,2⋅105); 1≤q≤2⋅105\n\n).\n\nThen m\nlines follow. The i-th of them contains two integers xi and yi (1≤xi≤n1; 1≤yi≤n2) meaning that the i-th edge connects the vertex xi in the first part and the vertex yi\n\nin the second part. There are no pairs of vertices that are connected by more than one edge.\n\nThen q\nlines follow. The i-th of them contains one integer, 1 or 2, denoting the i\n\n-th query. Additional constraints on queries:\n\n    the number of queries of type 1\n\nwon't exceed the size of the maximum matching in the initial graph;\nthe number of queries of type 2\nwon't exceed 3\n;\neach query of type 2\nis preceded by a query of type 1\n;\nyour solution is allowed to read the i\n-th query only after printing the answer for the (i−1)\n\n    -th query and flushing the output. \n\nOutput\n\nFor a query of type 1\n\n, print the answer in three lines as follows:\n\n    the first line should contain the number of vertices you remove;\n    the second line should contain the indices of vertices you remove, as follows: if you remove the vertex x\n\nfrom the left part, print x; if you remove the vertex y from the right part, print −y\n(negative index);\nthe third line should contain the sum of indices of edges in some maximum matching in the resulting graph. The edges are numbered from 1\nto m\n\n    . \n\nFor a query of type 2\n\n, print the answer in two lines as follows:\n\n    the first line should contain the size of the maximum matching;\n    the second line should contain the indices of the edges belonging to the maximum matching. Note that the sum of these indices should be equal to the number you printed at the end of the previous query of type 1\n\n    ; \n\nAfter printing the answer to a query, don't forget to flush the output.\nExample\nInput\nCopy\n\n3 4 4 4\n2 2\n1 3\n2 1\n3 4\n1\n2\n1\n2\n\nOutput\nCopy\n\n1\n-4\n3\n===\n2\n1 2\n===\n1\n2\n2\n===\n1\n2\n\nNote\n\nIn this problem, you may receive the verdict \"Idleness Limit Exceeded\" since it is in online mode. If it happens, it means that either the output format is wrong, or you don't meet some constraint of the problem. You may treat this verdict as \"Wrong Answer\".\n\nFor your convenience, the output for queries in the example is separated by the line ===. Don't print this line in your program, it is done only to make sure that it's easy to distinguish between answers for different queries in the statement."
        }
    ],
    "/contest/1709": [
        {
            "problem": "A",
            "task": "A. Three Doors\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere are three doors in front of you, numbered from 1\nto 3\n\nfrom left to right. Each door has a lock on it, which can only be opened with a key with the same number on it as the number on the door.\n\nThere are three keys — one for each door. Two of them are hidden behind the doors, so that there is no more than one key behind each door. So two doors have one key behind them, one door doesn't have a key behind it. To obtain a key hidden behind a door, you should first unlock that door. The remaining key is in your hands.\n\nCan you open all the doors?\nInput\n\nThe first line contains a single integer t\n(1≤t≤18\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer x\n(1≤x≤3\n\n) — the number on the key in your hands.\n\nThe second line contains three integers a,b\nand c (0≤a,b,c≤3) — the number on the key behind each of the doors. If there is no key behind the door, the number is equal to 0\n\n.\n\nValues 1,2\nand 3 appear exactly once among x,a,b and c\n\n.\nOutput\n\nFor each testcase, print \"YES\" if you can open all the doors. Otherwise, print \"NO\".\nExample\nInput\nCopy\n\n4\n3\n0 1 2\n1\n0 3 2\n2\n3 1 0\n2\n1 3 0\n\nOutput\nCopy\n\nYES\nNO\nYES\nNO\n"
        },
        {
            "problem": "B",
            "task": "B. Also Try Minecraft\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are beta testing the new secret Terraria update. This update will add quests to the game!\n\nSimply, the world map can be represented as an array of length n\n, where the i-th column of the world has height ai\n\n.\n\nThere are m\nquests you have to test. The j-th of them is represented by two integers sj and tj. In this quest, you have to go from the column sj to the column tj. At the start of the quest, you are appearing at the column sj\n\n.\n\nIn one move, you can go from the column x\nto the column x−1 or to the column x+1. In this version, you have Spectre Boots, which allow you to fly. Since it is a beta version, they are bugged, so they only allow you to fly when you are going up and have infinite fly duration. When you are moving from the column with the height p to the column with the height q, then you get some amount of fall damage. If the height p is greater than the height q, you get p−q fall damage, otherwise you fly up and get 0\n\ndamage.\n\nFor each of the given quests, determine the minimum amount of fall damage you can get during this quest.\nInput\n\nThe first line of the input contains two integers n\nand m (2≤n≤105;1≤m≤105\n\n) — the number of columns in the world and the number of quests you have to test, respectively.\n\nThe second line of the input contains n\nintegers a1,a2,…,an (1≤ai≤109), where ai is the height of the i\n\n-th column of the world.\n\nThe next m\nlines describe quests. The j-th of them contains two integers sj and tj (1≤sj,tj≤n;sj≠tj), which means you have to move from the column sj to the column tj during the j\n\n-th quest.\n\nNote that sj\ncan be greater than tj\n\n.\nOutput\n\nPrint m\nintegers. The j-th of them should be the minimum amount of fall damage you can get during the j\n\n-th quest completion.\nExample\nInput\nCopy\n\n7 6\n10 8 9 6 8 12 7\n1 2\n1 7\n4 6\n7 1\n3 5\n4 2\n\nOutput\nCopy\n\n2\n10\n0\n7\n3\n1\n"
        },
        {
            "problem": "C",
            "task": "C. Recover an RBS\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nA bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence (or, shortly, an RBS) is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example:\n\n    bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\");\n    bracket sequences \")(\", \"(\" and \")\" are not. \n\nThere was an RBS. Some brackets have been replaced with question marks. Is it true that there is a unique way to replace question marks with brackets, so that the resulting sequence is an RBS?\nInput\n\nThe first line contains a single integer t\n(1≤t≤5⋅104\n\n) — the number of testcases.\n\nThe only line of each testcase contains an RBS with some brackets replaced with question marks. Each character is either '(', ')' or '?'. At least one RBS can be recovered from the given sequence.\n\nThe total length of the sequences over all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print \"YES\" if the way to replace question marks with brackets, so that the resulting sequence is an RBS, is unique. If there is more than one way, then print \"NO\".\nExample\nInput\nCopy\n\n5\n(?))\n??????\n()\n??\n?(?)()?)\n\nOutput\nCopy\n\nYES\nNO\nYES\nYES\nNO\n\nNote\n\nIn the first testcase, the only possible original RBS is \"(())\".\n\nIn the second testcase, there are multiple ways to recover an RBS.\n\nIn the third and the fourth testcases, the only possible original RBS is \"()\".\n\nIn the fifth testcase, the original RBS can be either \"((()()))\" or \"(())()()\""
        },
        {
            "problem": "D",
            "task": "D. Rorororobot\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere is a grid, consisting of n\nrows and m columns. The rows are numbered from 1 to n from bottom to top. The columns are numbered from 1 to m from left to right. The i-th column has the bottom ai cells blocked (the cells in rows 1,2,…,ai), the remaining n−ai\n\ncells are unblocked.\n\nA robot is travelling across this grid. You can send it commands — move up, right, down or left. If a robot attempts to move into a blocked cell or outside the grid, it explodes.\n\nHowever, the robot is broken — it executes each received command k\ntimes. So if you tell it to move up, for example, it will move up k times (k\n\ncells). You can't send it commands while the robot executes the current one.\n\nYou are asked q\nqueries about the robot. Each query has a start cell, a finish cell and a value k. Can you send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command k\n\ntimes?\n\nThe robot must stop in the finish cell. If it visits the finish cell while still executing commands, it doesn't count.\nInput\n\nThe first line contains two integers n\nand m (1≤n≤109; 1≤m≤2⋅105\n\n) — the number of rows and columns of the grid.\n\nThe second line contains m\nintegers a1,a2,…,am (0≤ai≤n) — the number of blocked cells on the bottom of the i\n\n-th column.\n\nThe third line contains a single integer q\n(1≤q≤2⋅105\n\n) — the number of queries.\n\nEach of the next q\nlines contain five integers xs,ys,xf,yf and k (a[ys]<xs≤n; 1≤ys≤m; a[yf]<xf≤n; 1≤yf≤m; 1≤k≤109\n\n) — the row and the column of the start cell, the row and the column of the finish cell and the number of times each your command is executed. The start and the finish cell of each query are unblocked.\nOutput\n\nFor each query, print \"YES\" if you can send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command k\n\ntimes. Otherwise, print \"NO\".\nExample\nInput\nCopy\n\n11 10\n9 0 0 10 3 4 8 11 10 8\n6\n1 2 1 3 1\n1 2 1 3 2\n4 3 4 5 2\n5 3 11 5 3\n5 3 11 5 2\n11 9 9 10 1\n\nOutput\nCopy\n\nYES\nNO\nNO\nNO\nYES\nYES\n"
        },
        {
            "problem": "E",
            "task": "E. XOR Tree\ntime limit per test\n3 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a tree consisting of n\nvertices. A number is written on each vertex; the number on vertex i is equal to ai\n\n.\n\nRecall that a simple path is a path that visits each vertex at most once. Let the weight of the path be the bitwise XOR of the values written on vertices it consists of. Let's say that a tree is good if no simple path has weight 0\n\n.\n\nYou can apply the following operation any number of times (possibly, zero): select a vertex of the tree and replace the value written on it with an arbitrary positive integer. What is the minimum number of times you have to apply this operation in order to make the tree good?\nInput\n\nThe first line contains one integer n\n(1≤n≤2⋅105\n\n) — the number of vertices.\n\nThe second line contains n\nintegers a1, a2, ..., an (1≤ai<230\n\n) — the numbers written on vertices.\n\nThen n−1\nlines follow, each containing two integers x and y (1≤x,y≤n;x≠y) denoting an edge connecting vertex x with vertex y\n\n. It is guaranteed that these edges form a tree.\nOutput\n\nPrint a single integer — the minimum number of times you have to apply the operation in order to make the tree good.\nExamples\nInput\nCopy\n\n6\n3 2 1 3 2 1\n4 5\n3 4\n1 4\n2 1\n6 1\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n4\n2 1 1 1\n1 2\n1 3\n1 4\n\nOutput\nCopy\n\n0\n\nInput\nCopy\n\n5\n2 2 2 2 2\n1 2\n2 3\n3 4\n4 5\n\nOutput\nCopy\n\n2\n\nNote\n\nIn the first example, it is enough to replace the value on the vertex 1\nwith 13, and the value on the vertex 4 with 42."
        },
        {
            "problem": "F",
            "task": "F. Multiset of Strings\ntime limit per test\n6 seconds\nmemory limit per test\n512 megabytes\n\nYou are given three integers n\n, k and f\n\n.\n\nConsider all binary strings (i. e. all strings consisting of characters 0\nand/or 1) of length from 1 to n. For every such string s, you need to choose an integer cs from 0 to k\n\n.\n\nA multiset of binary strings of length exactly n\nis considered beautiful if for every binary string s with length from 1 to n, the number of strings in the multiset such that s is their prefix is not exceeding cs\n\n.\n\nFor example, let n=2\n, c0=3, c00=1, c01=2, c1=1, c10=2, and c11=3. The multiset of strings {11,01,00,01}\n\nis beautiful, since:\n\n    for the string 0\n\n, there are 3 strings in the multiset such that 0 is their prefix, and 3≤c0\n;\nfor the string 00\n, there is one string in the multiset such that 00 is its prefix, and 1≤c00\n;\nfor the string 01\n, there are 2 strings in the multiset such that 01 is their prefix, and 2≤c01\n;\nfor the string 1\n, there is one string in the multiset such that 1 is its prefix, and 1≤c1\n;\nfor the string 10\n, there are 0 strings in the multiset such that 10 is their prefix, and 0≤c10\n;\nfor the string 11\n, there is one string in the multiset such that 11 is its prefix, and 1≤c11\n\n    . \n\nNow, for the problem itself. You have to calculate the number of ways to choose the integer cs\nfor every binary string s of length from 1 to n in such a way that the maximum possible size of a beautiful multiset is exactly f\n\n.\nInput\n\nThe only line of input contains three integers n\n, k and f (1≤n≤15; 1≤k,f≤2⋅105\n\n).\nOutput\n\nPrint one integer — the number of ways to choose the integer cs\nfor every binary string s of length from 1 to n in such a way that the maximum possible size of a beautiful multiset is exactly f. Since it can be huge, print it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n1 42 2\n\nOutput\nCopy\n\n3\n\nInput\nCopy\n\n2 37 13\n\nOutput\nCopy\n\n36871576\n\nInput\nCopy\n\n4 1252 325\n\nOutput\nCopy\n\n861735572\n\nInput\nCopy\n\n6 153 23699\n\nOutput\nCopy\n\n0\n\nInput\nCopy\n\n15 200000 198756\n\nOutput\nCopy\n\n612404746\n\nNote\n\nIn the first example, the three ways to choose the integers cs\n\nare:\n\n    c0=0\n\n, c1=2, then the maximum beautiful multiset is {1,1}\n;\nc0=1\n, c1=1, then the maximum beautiful multiset is {0,1}\n;\nc0=2\n, c1=0, then the maximum beautiful multiset is {0,0}. "
        }
    ],
    "/contest/1657": [
        {
            "problem": "A",
            "task": "A. Integer Moves\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere's a chip in the point (0,0)\nof the coordinate plane. In one operation, you can move the chip from some point (x1,y1) to some point (x2,y2) if the Euclidean distance between these two points is an integer (i.e. (x1−x2)2+(y1−y2)2−−−−−−−−−−−−−−−−−−√\n\nis integer).\n\nYour task is to determine the minimum number of operations required to move the chip from the point (0,0)\nto the point (x,y)\n\n.\nInput\n\nThe first line contains a single integer t\n(1≤t≤3000\n\n) — number of test cases.\n\nThe single line of each test case contains two integers x\nand y (0≤x,y≤50\n\n) — the coordinates of the destination point.\nOutput\n\nFor each test case, print one integer — the minimum number of operations required to move the chip from the point (0,0)\nto the point (x,y)\n\n.\nExample\nInput\nCopy\n\n3\n8 6\n0 0\n9 15\n\nOutput\nCopy\n\n1\n0\n2\n\nNote\n\nIn the first example, one operation (0,0)→(8,6)\nis enough. (0−8)2+(0−6)2−−−−−−−−−−−−−−−√=64+36−−−−−−√=100−−−√=10\n\nis an integer.\n\nIn the second example, the chip is already at the destination point.\n\nIn the third example, the chip can be moved as follows: (0,0)→(5,12)→(9,15)\n. (0−5)2+(0−12)2−−−−−−−−−−−−−−−−√=25+144−−−−−−−√=169−−−√=13 and (5−9)2+(12−15)2−−−−−−−−−−−−−−−−−√=16+9−−−−−√=25−−√=5 are integers."
        },
        {
            "problem": "B",
            "task": "B. XY Sequence\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given four integers n\n, B, x and y. You should build a sequence a0,a1,a2,…,an where a0=0 and for each i≥1\n\nyou can choose:\n\n    either ai=ai−1+x\n\nor ai=ai−1−y\n\n    . \n\nYour goal is to build such a sequence a\nthat ai≤B for all i and ∑i=0nai\n\nis maximum possible.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104) — the number of test cases. Next t\n\ncases follow.\n\nThe first and only line of each test case contains four integers n\n, B, x and y (1≤n≤2⋅105; 1≤B,x,y≤109\n\n).\n\nIt's guaranteed that the total sum of n\ndoesn't exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print one integer — the maximum possible ∑i=0nai\n\n.\nExample\nInput\nCopy\n\n3\n5 100 1 30\n7 1000000000 1000000000 1000000000\n4 1 7 3\n\nOutput\nCopy\n\n15\n4000000000\n-10\n\nNote\n\nIn the first test case, the optimal sequence a\nis [0,1,2,3,4,5]\n\n.\n\nIn the second test case, the optimal sequence a\nis [0,109,0,109,0,109,0,109]\n\n.\n\nIn the third test case, the optimal sequence a\nis [0,−3,−6,1,−2]."
        },
        {
            "problem": "C",
            "task": "C. Bracket Sequence Deletion\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a bracket sequence consisting of n\n\ncharacters '(' and/or )'. You perform several operations with it.\n\nDuring one operation, you choose the shortest prefix of this string (some amount of first characters of the string) that is good and remove it from the string.\n\nThe prefix is considered good if one of the following two conditions is satisfied:\n\n    this prefix is a regular bracket sequence;\n    this prefix is a palindrome of length at least two. \n\nA bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not.\n\nThe bracket sequence is called palindrome if it reads the same back and forth. For example, the bracket sequences )), (( and )(() are palindromes, while bracket sequences (), )( and ))( are not palindromes.\n\nYou stop performing the operations when it's not possible to find a good prefix. Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string.\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤104) — the number of test cases. The next 2t\n\nlines describe test cases.\n\nThe first line of the test case contains one integer n\n(1≤n≤5⋅105\n\n) — the length of the bracket sequence.\n\nThe second line of the test case contains n\n\ncharacters '(' and/or ')' — the bracket sequence itself.\n\nIt is guaranteed that the sum of n\nover all test cases do not exceed 5⋅105 (∑n≤5⋅105\n\n).\nOutput\n\nFor each test case, print two integers c\nand r\n\n— the number of operations you will perform on the given bracket sequence and the number of characters that remain in the string after performing all operations.\nExample\nInput\nCopy\n\n5\n2\n()\n3\n())\n4\n((((\n5\n)((()\n6\n)((()(\n\nOutput\nCopy\n\n1 0\n1 1\n2 0\n1 0\n1 1\n"
        },
        {
            "problem": "D",
            "task": "D. For Gamers. By Gamers.\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp is playing a strategy game. In the game, he recruits a squad to fight monsters. Before each battle, Monocarp has C\n\ncoins to spend on his squad.\n\nBefore each battle starts, his squad is empty. Monocarp chooses one type of units and recruits no more units of that type than he can recruit with C\n\ncoins.\n\nThere are n\n\ntypes of units. Every unit type has three parameters:\n\n    ci\n\n — the cost of recruiting one unit of the i\n-th type;\ndi\n — the damage that one unit of the i\n-th type deals in a second;\nhi\n — the amount of health of one unit of the i\n\n    -th type. \n\nMonocarp has to face m\n\nmonsters. Every monster has two parameters:\n\n    Dj\n\n — the damage that the j\n-th monster deals in a second;\nHj\n — the amount of health the j\n\n    -th monster has. \n\nMonocarp has to fight only the j\n-th monster during the j\n\n-th battle. He wants all his recruited units to stay alive. Both Monocarp's squad and the monster attack continuously (not once per second) and at the same time. Thus, Monocarp wins the battle if and only if his squad kills the monster strictly faster than the monster kills one of his units. The time is compared with no rounding.\n\nFor each monster, Monocarp wants to know the minimum amount of coins he has to spend to kill that monster. If this amount is greater than C\n\n, then report that it's impossible to kill that monster.\nInput\n\nThe first line contains two integers n\nand C (1≤n≤3⋅105; 1≤C≤106\n\n) — the number of types of units and the amount of coins Monocarp has before each battle.\n\nThe i\n-th of the next n lines contains three integers ci,di and hi (1≤ci≤C; 1≤di,hi≤106\n\n).\n\nThe next line contains a single integer m\n(1≤m≤3⋅105\n\n) — the number of monsters that Monocarp has to face.\n\nThe j\n-th of the next m lines contains two integers Dj and Hj (1≤Dj≤106; 1≤Hj≤1012\n\n).\nOutput\n\nPrint m\nintegers. For each monster, print the minimum amount of coins Monocarp has to spend to kill that monster. If this amount is greater than C, then print −1\n\n.\nExamples\nInput\nCopy\n\n3 10\n3 4 6\n5 5 5\n10 3 4\n3\n8 3\n5 4\n10 15\n\nOutput\nCopy\n\n5 3 -1 \n\nInput\nCopy\n\n5 15\n14 10 3\n9 2 2\n10 4 3\n7 3 5\n4 3 1\n6\n11 2\n1 1\n4 7\n2 1\n1 14\n3 3\n\nOutput\nCopy\n\n14 4 14 4 7 7 \n\nInput\nCopy\n\n5 13\n13 1 9\n6 4 5\n12 18 4\n9 13 2\n5 4 5\n2\n16 3\n6 2\n\nOutput\nCopy\n\n12 5 \n\nNote\n\nConsider the first monster of the first example.\n\nMonocarp can't recruit one unit of the first type, because it will take both him and the monster 0.75\nseconds to kill each other. He can recruit two units for the cost of 6 coins and kill the monster in 0.375\n\nsecond.\n\nMonocarp can recruit one unit of the second type, because he kills the monster in 0.6\nseconds, and the monster kills him in 0.625 seconds. The unit is faster. Thus, 5\n\ncoins is enough.\n\nMonocarp will need at least three units of the third type to kill the first monster, that will cost 30\n\ncoins.\n\nMonocarp will spend the least coins if he chooses the second type of units and recruits one unit of that type."
        },
        {
            "problem": "E",
            "task": "E. Star MST\ntime limit per test\n6 seconds\nmemory limit per test\n512 megabytes\n\nIn this problem, we will consider complete undirected graphs consisting of n\nvertices with weighted edges. The weight of each edge is an integer from 1 to k\n\n.\n\nAn undirected graph is considered beautiful if the sum of weights of all edges incident to vertex 1\nis equal to the weight of MST in the graph. MST is the minimum spanning tree — a tree consisting of n−1 edges of the graph, which connects all n\n\nvertices and has the minimum sum of weights among all such trees; the weight of MST is the sum of weights of all edges in it.\n\nCalculate the number of complete beautiful graphs having exactly n\nvertices and the weights of edges from 1 to k. Since the answer might be large, print it modulo 998244353\n\n.\nInput\n\nThe only line contains two integers n\nand k (2≤n≤250; 1≤k≤250\n\n).\nOutput\n\nPrint one integer — the number of complete beautiful graphs having exactly n\nvertices and the weights of edges from 1 to k. Since the answer might be large, print it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n3 2\n\nOutput\nCopy\n\n5\n\nInput\nCopy\n\n4 4\n\nOutput\nCopy\n\n571\n\nInput\nCopy\n\n6 9\n\nOutput\nCopy\n\n310640163\n\nInput\nCopy\n\n42 13\n\nOutput\nCopy\n\n136246935\n\n"
        },
        {
            "problem": "F",
            "task": "F. Words on Tree\ntime limit per test\n9 seconds\nmemory limit per test\n1024 megabytes\n\nYou are given a tree consisting of n\nvertices, and q triples (xi,yi,si), where xi and yi are integers from 1 to n, and si is a string with length equal to the number of vertices on the simple path from xi to yi\n\n.\n\nYou want to write a lowercase Latin letter on each vertex in such a way that, for each of q\n\ngiven triples, at least one of the following conditions holds:\n\n    if you write out the letters on the vertices on the simple path from xi\n\nto yi in the order they appear on this path, you get the string si\n;\nif you write out the letters on the vertices on the simple path from yi\nto xi in the order they appear on this path, you get the string si\n\n    . \n\nFind any possible way to write a letter on each vertex to meet these constraints, or report that it is impossible.\nInput\n\nThe first line contains two integers n\nand q (2≤n≤4⋅105; 1≤q≤4⋅105\n\n) — the number of vertices in the tree and the number of triples, respectively.\n\nThen n−1\nlines follow; the i-th of them contains two integers ui and vi (1≤ui,vi≤n; ui≠vi) — the endpoints of the i\n\n-th edge. These edges form a tree.\n\nThen q\nlines follow; the j-th of them contains two integers xj and yj, and a string sj consisting of lowercase Latin letters. The length of sj is equal to the number of vertices on the simple path between xj and yj\n\n.\n\nAdditional constraint on the input: ∑j=1q|sj|≤4⋅105\n\n.\nOutput\n\nIf there is no way to meet the conditions on all triples, print NO. Otherwise, print YES in the first line, and a string of n\nlowercase Latin letters in the second line; the i-th character of the string should be the letter you write on the i\n\n-th vertex. If there are multiple answers, print any of them.\nExamples\nInput\nCopy\n\n3 2\n2 3\n2 1\n2 1 ab\n2 3 bc\n\nOutput\nCopy\n\nYES\nabc\n\nInput\nCopy\n\n3 2\n2 3\n2 1\n2 1 ab\n2 3 cd\n\nOutput\nCopy\n\nNO\n\nInput\nCopy\n\n10 10\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2 ab\n1 3 ab\n1 4 ab\n1 5 ab\n1 6 ab\n1 7 ab\n1 8 ab\n1 9 ab\n1 10 ab\n10 2 aba\n\nOutput\nCopy\n\nYES\nbaaaaaaaaa\n\nInput\nCopy\n\n10 10\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n1 8\n1 9\n1 10\n1 2 ab\n1 3 ab\n1 4 aa\n1 5 ab\n1 6 ab\n1 7 ab\n1 8 ab\n1 9 ab\n1 10 ab\n10 2 aba\n\nOutput\nCopy\n\nNO\n"
        }
    ],
    "/contest/1697": [
        {
            "problem": "A",
            "task": "A. Parkway Walk\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nYou are walking through a parkway near your house. The parkway has n+1\nbenches in a row numbered from 1 to n+1 from left to right. The distance between the bench i and i+1 is ai\n\nmeters.\n\nInitially, you have m\nunits of energy. To walk 1 meter of distance, you spend 1 unit of your energy. You can't walk if you have no energy. Also, you can restore your energy by sitting on benches (and this is the only way to restore the energy). When you are sitting, you can restore any integer amount of energy you want (if you sit longer, you restore more energy). Note that the amount of your energy can exceed m\n\n.\n\nYour task is to find the minimum amount of energy you have to restore (by sitting on benches) to reach the bench n+1\nfrom the bench 1\n\n(and end your walk).\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤100) — the number of test cases. Then t\n\ntest cases follow.\n\nThe first line of the test case contains two integers n\nand m (1≤n≤100; 1≤m≤104\n\n).\n\nThe second line of the test case contains n\nintegers a1,a2,…,an (1≤ai≤100), where ai is the distance between benches i and i+1\n\n.\nOutput\n\nFor each test case, print one integer — the minimum amount of energy you have to restore (by sitting on benches) to reach the bench n+1\nfrom the bench 1\n\n(and end your walk) in the corresponding test case.\nExample\nInput\nCopy\n\n3\n3 1\n1 2 1\n4 5\n3 3 5 2\n5 16\n1 2 3 4 5\n\nOutput\nCopy\n\n3\n8\n0\n\nNote\n\nIn the first test case of the example, you can walk to the bench 2\n, spending 1 unit of energy, then restore 2 units of energy on the second bench, walk to the bench 3, spending 2 units of energy, restore 1 unit of energy and go to the bench 4\n\n.\n\nIn the third test case of the example, you have enough energy to just go to the bench 6\nwithout sitting at all."
        },
        {
            "problem": "B",
            "task": "B. Promo\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThe store sells n\nitems, the price of the i-th item is pi. The store's management is going to hold a promotion: if a customer purchases at least x items, y\n\ncheapest of them are free.\n\nThe management has not yet decided on the exact values of x\nand y. Therefore, they ask you to process q queries: for the given values of x and y\n\n, determine the maximum total value of items received for free, if a customer makes one purchase.\n\nNote that all queries are independent; they don't affect the store's stock.\nInput\n\nThe first line contains two integers n\nand q (1≤n,q≤2⋅105\n\n) — the number of items in the store and the number of queries, respectively.\n\nThe second line contains n\nintegers p1,p2,…,pn (1≤pi≤106), where pi — the price of the i\n\n-th item.\n\nThe following q\nlines contain two integers xi and yi each (1≤yi≤xi≤n) — the values of the parameters x and y in the i\n\n-th query.\nOutput\n\nFor each query, print a single integer — the maximum total value of items received for free for one purchase.\nExample\nInput\nCopy\n\n5 3\n5 3 1 5 2\n3 2\n1 1\n5 3\n\nOutput\nCopy\n\n8\n5\n6\n\nNote\n\nIn the first query, a customer can buy three items worth 5,3,5\n, the two cheapest of them are 3+5=8\n\n.\n\nIn the second query, a customer can buy two items worth 5\nand 5, the cheapest of them is 5\n\n.\n\nIn the third query, a customer has to buy all the items to receive the three cheapest of them for free; their total price is 1+2+3=6\n."
        },
        {
            "problem": "C",
            "task": "C. awoo's Favorite Problem\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given two strings s\nand t, both of length n\n\n. Each character in both string is 'a', 'b' or 'c'.\n\nIn one move, you can perform one of the following actions:\n\n    choose an occurrence of \"ab\" in s\n\nand replace it with \"ba\";\nchoose an occurrence of \"bc\" in s\n\n    and replace it with \"cb\". \n\nYou are allowed to perform an arbitrary amount of moves (possibly, zero). Can you change string s\nto make it equal to string t\n\n?\nInput\n\nThe first line contains a single integer q\n(1≤q≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(1≤n≤105) — the length of strings s and t\n\n.\n\nThe second line contains string s\nof length n\n\n. Each character is 'a', 'b' or 'c'.\n\nThe third line contains string t\nof length n\n\n. Each character is 'a', 'b' or 'c'.\n\nThe sum of n\nover all testcases doesn't exceed 105\n\n.\nOutput\n\nFor each testcase, print \"YES\" if you can change string s\nto make it equal to string t\n\nby performing an arbitrary amount of moves (possibly, zero). Otherwise, print \"NO\".\nExample\nInput\nCopy\n\n5\n3\ncab\ncab\n1\na\nb\n6\nabbabc\nbbaacb\n10\nbcaabababc\ncbbababaac\n2\nba\nab\n\nOutput\nCopy\n\nYES\nNO\nYES\nYES\nNO\n"
        },
        {
            "problem": "D",
            "task": "D. Guess The String\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nThis is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https://codeforces.com/blog/entry/45307.\n\nThe jury has chosen a string s\nconsisting of n characters; each character of s\n\nis a lowercase Latin letter. Your task is to guess this string; initially, you know only its length.\n\nYou may ask queries of two types:\n\n    1\n\ni — the query of the first type, where i is an integer from 1 to n. In response to this query, the jury will tell you the character si\n;\n2\nl r — the query of the second type, where l and r are integers such that 1≤l≤r≤n. In response to this query, the jury will tell you the number of different characters among sl,sl+1,…,sr\n\n    . \n\nYou are allowed to ask no more than 26\nqueries of the first type, and no more than 6000 queries of the second type. Your task is to restore the string s\n\n.\n\nFor each test in this problem, the string s\n\nis fixed beforehand, and will be the same for every submission.\nInput\n\nInitially, the jury program sends one integer n\non a separate line — the size of s (1≤n≤1000\n\n).\nOutput\n\nTo give the answer, print one line ! s with a line break in the end, where s\n\nshould be the string picked by the jury. After that, your program should flush the output and terminate gracefully.\nInteraction\n\nTo ask a query, you should send one line containing the query, in one of the following formats:\n\n    ? 1 i — for a query of the first type (1≤i≤n\n\n);\n? 2 l r — for a query of the second type (1≤l≤r≤n\n\n    ). \n\nDon't forget to flush the output after sending the query line.\n\nThe answer to your query will be given on a separate line. For a query of the first type, the answer will be the character si\n. For a query of the second type, the answer will be an integer equal to the number of different characters among sl,sl+1,…,sr\n\n.\n\nYou are allowed to ask no more than 26\nqueries of the first type, and no more than 6000\n\nqueries of the second type.\n\nIn case you ask too many queries, or the jury program fails to recognize your query format, the answer to your query will be one integer 0\n. After receiving 0\n\nas the answer, your program should terminate immediately — otherwise you may receive verdict \"Runtime error\", \"Time limit exceeded\" or some other verdict instead of \"Wrong answer\".\nExample\nInput\nCopy\n\n5\n4\nu\n2\ng\ne\ns\n1\n\nOutput\nCopy\n\n? 2 1 5\n? 1 2\n? 2 1 2\n? 1 1\n? 1 3\n? 1 4\n? 2 4 5\n! guess\n\nNote\n\nLet's analyze the example of interaction.\n\nThe string chosen by the jury is guess, so initially the jury sends one integer 5\n\n.\n\n    the first query is ? 2 1 5, which means \"count the number of different characters among s1,s2,…,s5\n\n\". The answer to it is 4\n.\nthe second query is ? 1 2, which means \"tell which character is s2\n\". The answer to it is u.\nthe third query is ? 2 1 2, which means \"count the number of different characters among s1\nand s2\". The answer to it is 2\n.\nthe fourth query is ? 1 1, which means \"tell which character is s1\n\". The answer to it is g.\nthe fifth query is ? 1 3, which means \"tell which character is s3\n\". The answer to it is e.\nthe sixth query is ? 1 4, which means \"tell which character is s4\n\". The answer to it is s.\nthe seventh query is ? 2 4 5, which means \"count the number of different characters among s4\nand s5\". The answer to it is 1, so it's possible to deduce that s4 is the same as s5\n\n    .\n\nIn the end, the answer is submitted as ! guess, and it is deduced correctly."
        },
        {
            "problem": "E",
            "task": "E. Coloring\ntime limit per test\n3 seconds\nmemory limit per test\n512 megabytes\n\nYou are given n\npoints on the plane, the coordinates of the i-th point are (xi,yi)\n\n. No two points have the same coordinates.\n\nThe distance between points i\nand j is defined as d(i,j)=|xi−xj|+|yi−yj|\n\n.\n\nFor each point, you have to choose a color, represented by an integer from 1\nto n. For every ordered triple of different points (a,b,c)\n\n, the following constraints should be met:\n\n    if a\n\n, b and c have the same color, then d(a,b)=d(a,c)=d(b,c)\n;\nif a\nand b have the same color, and the color of c is different from the color of a, then d(a,b)<d(a,c) and d(a,b)<d(b,c)\n\n    . \n\nCalculate the number of different ways to choose the colors that meet these constraints.\nInput\n\nThe first line contains one integer n\n(2≤n≤100\n\n) — the number of points.\n\nThen n\nlines follow. The i-th of them contains two integers xi and yi (0≤xi,yi≤108\n\n).\n\nNo two points have the same coordinates (i. e. if i≠j\n, then either xi≠xj or yi≠yj\n\n).\nOutput\n\nPrint one integer — the number of ways to choose the colors for the points. Since it can be large, print it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n3\n1 0\n3 0\n2 1\n\nOutput\nCopy\n\n9\n\nInput\nCopy\n\n5\n1 2\n2 4\n3 4\n4 4\n1 3\n\nOutput\nCopy\n\n240\n\nInput\nCopy\n\n4\n1 0\n3 0\n2 1\n2 0\n\nOutput\nCopy\n\n24\n\nNote\n\nIn the first test, the following ways to choose the colors are suitable:\n\n    [1,1,1]\n\n;\n[2,2,2]\n;\n[3,3,3]\n;\n[1,2,3]\n;\n[1,3,2]\n;\n[2,1,3]\n;\n[2,3,1]\n;\n[3,1,2]\n;\n[3,2,1]\n. "
        },
        {
            "problem": "F",
            "task": "F. Too Many Constraints\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are asked to build an array a\n, consisting of n integers, each element should be from 1 to k\n\n.\n\nThe array should be non-decreasing (ai≤ai+1\nfor all i from 1 to n−1\n\n).\n\nYou are also given additional constraints on it. Each constraint is of one of three following types:\n\n    1 i x\n\n: ai should not be equal to x\n;\n2 i j x\n: ai+aj should be less than or equal to x\n;\n3 i j x\n: ai+aj should be greater than or equal to x\n\n    . \n\nBuild any non-decreasing array that satisfies all constraints or report that no such array exists.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains three integers n,m\nand k (2≤n≤2⋅104; 0≤m≤2⋅104; 2≤k≤10\n\n).\n\nThe i\n-th of the next m\n\nlines contains a description of a constraint. Each constraint is of one of three following types:\n\n    1 i x\n\n(1≤i≤n; 1≤x≤k): ai should not be equal to x\n;\n2 i j x\n(1≤i<j≤n; 2≤x≤2⋅k): ai+aj should be less than or equal to x\n;\n3 i j x\n(1≤i<j≤n; 2≤x≤2⋅k): ai+aj should be greater than or equal to x\n\n    . \n\nThe sum of n\nover all testcases doesn't exceed 2⋅104. The sum of m over all testcases doesn't exceed 2⋅104\n\n.\nOutput\n\nFor each testcase, determine if there exists a non-decreasing array that satisfies all conditions. If there is no such array, then print -1. Otherwise, print any valid array — n\nintegers from 1 to k\n\n.\nExample\nInput\nCopy\n\n4\n4 0 4\n2 2 3\n3 1 2 3\n1 2 2\n3 3 2\n1 1 1\n2 2 3 2\n3 2 3 2\n5 5 5\n3 2 5 7\n2 4 5 10\n3 4 5 6\n3 3 4 7\n2 1 5 7\n\nOutput\nCopy\n\n1 2 3 4\n1 3\n-1\n1 2 2 5 5\n"
        }
    ],
    "/contest/1671": [
        {
            "problem": "A",
            "task": "A. String Building\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a string s\n. You have to determine whether it is possible to build the string s\n\nout of strings aa, aaa, bb and/or bbb by concatenating them. You can use the strings aa, aaa, bb and/or bbb any number of times and in any order.\n\nFor example:\n\n    aaaabbb can be built as aa +\n\naa +\nbbb;\nbbaaaaabbb can be built as bb +\naaa + aa +\nbbb;\naaaaaa can be built as aa +\naa +\n\n    aa;\n    abab cannot be built from aa, aaa, bb and/or bbb. \n\nInput\n\nThe first line contains one integer t\n(1≤t≤1000\n\n) — the number of test cases.\n\nEach test case consists of one line containing the string s\n(1≤|s|≤50\n\n), consisting of characters a and/or b.\nOutput\n\nFor each test case, print YES if it is possible to build the string s\n\n. Otherwise, print NO.\n\nYou may print each letter in any case (for example, YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\nExample\nInput\nCopy\n\n8\naaaabbb\nbbaaaaabbb\naaaaaa\nabab\na\nb\naaaab\nbbaaa\n\nOutput\nCopy\n\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nYES\n\nNote\n\nThe first four test cases of the example are described in the statement."
        },
        {
            "problem": "B",
            "task": "B. Consecutive Points Segment\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given n\npoints with integer coordinates on a coordinate axis OX. The coordinate of the i-th point is xi\n\n. All points' coordinates are distinct and given in strictly increasing order.\n\nFor each point i\n, you can do the following operation no more than once: take this point and move it by 1 to the left or to the right (i..e., you can change its coordinate xi to xi−1 or to xi+1). In other words, for each point, you choose (separately) its new coordinate. For the i-th point, it can be either xi−1, xi or xi+1\n\n.\n\nYour task is to determine if you can move some points as described above in such a way that the new set of points forms a consecutive segment of integers, i. e. for some integer l\nthe coordinates of points should be equal to l,l+1,…,l+n−1\n\n.\n\nNote that the resulting points should have distinct coordinates.\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤2⋅104) — the number of test cases. Then t\n\ntest cases follow.\n\nThe first line of the test case contains one integer n\n(1≤n≤2⋅105) — the number of points in the set x\n\n.\n\nThe second line of the test case contains n\nintegers x1<x2<…<xn (1≤xi≤106), where xi is the coordinate of the i\n\n-th point.\n\nIt is guaranteed that the points are given in strictly increasing order (this also means that all coordinates are distinct). It is also guaranteed that the sum of n\ndoes not exceed 2⋅105 (∑n≤2⋅105\n\n).\nOutput\n\nFor each test case, print the answer — if the set of points from the test case can be moved to form a consecutive segment of integers, print YES, otherwise print NO.\nExample\nInput\nCopy\n\n5\n2\n1 4\n3\n1 2 3\n4\n1 2 3 7\n1\n1000000\n3\n2 5 6\n\nOutput\nCopy\n\nYES\nYES\nNO\nYES\nYES\n"
        },
        {
            "problem": "C",
            "task": "C. Dolce Vita\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nTurbulent times are coming, so you decided to buy sugar in advance. There are n\nshops around that sell sugar: the i-th shop sells one pack of sugar for ai\n\ncoins, but only one pack to one customer each day. So in order to buy several packs, you need to visit several shops.\n\nAnother problem is that prices are increasing each day: during the first day the cost is ai\n, during the second day cost is ai+1, during the third day — ai+2 and so on for each shop i\n\n.\n\nOn the contrary, your everyday budget is only x\ncoins. In other words, each day you go and buy as many packs as possible with total cost not exceeding x\n\n. Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.\n\nEventually, the cost for each pack will exceed x\n\n, and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?\nInput\n\nThe first line contains a single integer t\n(1≤t≤1000) — the number of test cases. Next t\n\ncases follow.\n\nThe first line of each test case contains two integers n\nand x (1≤n≤2⋅105; 1≤x≤109\n\n) — the number of shops and your everyday budget.\n\nThe second line of each test case contains n\nintegers a1,a2,…,an (1≤ai≤109\n\n) — the initial cost of one pack in each shop.\n\nIt's guaranteed that the total sum of n\ndoesn't exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print one integer — the total number of packs you will be able to buy until prices exceed your everyday budget.\nExample\nInput\nCopy\n\n4\n3 7\n2 1 2\n5 9\n10 20 30 40 50\n1 1\n1\n2 1000\n1 1\n\nOutput\nCopy\n\n11\n0\n1\n1500\n\nNote\n\nIn the first test case,\n\n    Day 1: prices are [2,1,2]\n\n. You can buy all 3 packs, since 2+1+2≤7\n.\nDay 2: prices are [3,2,3]\n. You can't buy all 3 packs, since 3+2+3>7, so you buy only 2\npacks.\nDay 3: prices are [4,3,4]\n. You can buy 2 packs with prices 4 and 3\n.\nDay 4: prices are [5,4,5]\n. You can't buy 2 packs anymore, so you buy only 1\npack.\nDay 5: prices are [6,5,6]\n. You can buy 1\npack.\nDay 6: prices are [7,6,7]\n. You can buy 1\npack.\nDay 7: prices are [8,7,8]\n. You still can buy 1 pack of cost 7\n.\nDay 8: prices are [9,8,9]\n\n    . Prices are too high, so you can't buy anything. \n\nIn total, you bought 3+2+2+1+1+1+1=11 packs.\n\nIn the second test case, prices are too high even at the first day, so you can't buy anything.\n\nIn the third test case, you can buy only one pack at day one.\n\nIn the fourth test case, you can buy 2\npacks first 500 days. At day 501 prices are [501,501], so you can buy only 1 pack the next 500 days. At day 1001 prices are [1001,1001] so can't buy anymore. In total, you bought 500⋅2+500⋅1=1500 packs."
        },
        {
            "problem": "D",
            "task": "D. Insert a Progression\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a sequence of n\nintegers a1,a2,…,an. You are also given x integers 1,2,…,x\n\n.\n\nYou are asked to insert each of the extra integers into the sequence a\n\n. Each integer can be inserted at the beginning of the sequence, at the end of the sequence, or between any elements of the sequence.\n\nThe score of the resulting sequence a′\nis the sum of absolute differences of adjacent elements in it (∑i=1n+x−1|a′i−a′i+1|)\n\n.\n\nWhat is the smallest possible score of the resulting sequence a′\n\n?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains two integers n\nand x (1≤n,x≤2⋅105\n\n) — the length of the sequence and the number of extra integers.\n\nThe second line of each testcase contains n\nintegers a1,a2,…,an (1≤ai≤2⋅105\n\n).\n\nThe sum of n\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the smallest sum of absolute differences of adjacent elements of the sequence after you insert the extra integers into it.\nExample\nInput\nCopy\n\n4\n1 5\n10\n3 8\n7 2 10\n10 2\n6 1 5 7 3 3 9 10 10 1\n4 10\n1 3 1 2\n\nOutput\nCopy\n\n9\n15\n31\n13\n\nNote\n\nHere are the sequences with the smallest scores for the example. The underlined elements are the extra integers. Note that there exist other sequences with this smallest score.\n\n    1–,2–,3–,4–,5–,10\n\n7–,7,6–,4–,2,2–,1–,3–,5–,8–,10\n6,1–,1,2–,5,7,3,3,9,10,10,1\n1,3,1–,1,2,2–,3–,4–,5–,6–,7–,8–,9–,10–––"
        },
        {
            "problem": "E",
            "task": "E. Preorder\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a rooted tree of 2n−1\nvertices. Every vertex of this tree has either 0 children, or 2\n\nchildren. All leaves of this tree have the same distance from the root, and for every non-leaf vertex, one of its children is the left one, and the other child is the right one. Formally, you are given a perfect binary tree.\n\nThe vertices of the tree are numbered in the following order:\n\n    the root has index 1\n\n;\nif a vertex has index x\n, then its left child has index 2x, and its right child has index 2x+1\n\n    . \n\nEvery vertex of the tree has a letter written on it, either A or B. Let's define the character on the vertex x\nas sx\n\n.\n\nLet the preorder string of some vertex x\n\nbe defined in the following way:\n\n    if the vertex x\n\nis a leaf, then the preorder string of x be consisting of only one character sx\n;\notherwise, the preorder string of x\nis sx+f(lx)+f(rx), where + operator defines concatenation of strings, f(lx) is the preorder string of the left child of x, and f(rx) is the preorder string of the right child of x\n\n    . \n\nThe preorder string of the tree is the preorder string of its root.\n\nNow, for the problem itself...\n\nYou have to calculate the number of different strings that can be obtained as the preorder string of the given tree, if you are allowed to perform the following operation any number of times before constructing the preorder string of the tree:\n\n    choose any non-leaf vertex x\n\n    , and swap its children (so, the left child becomes the right one, and vice versa). \n\nInput\n\nThe first line contains one integer n\n(2≤n≤18\n\n).\n\nThe second line contains a sequence of 2n−1\ncharacters s1,s2,…,s2n−1\n\n. Each character is either A or B. The characters are not separated by spaces or anything else.\nOutput\n\nPrint one integer — the number of different strings that can be obtained as the preorder string of the given tree, if you can apply any number of operations described in the statement. Since it can be very large, print it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n4\nBAAAAAAAABBABAB\n\nOutput\nCopy\n\n16\n\nInput\nCopy\n\n2\nBAA\n\nOutput\nCopy\n\n1\n\nInput\nCopy\n\n2\nABA\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n2\nAAB\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n2\nAAA\n\nOutput\nCopy\n\n1\n"
        },
        {
            "problem": "F",
            "task": "F. Permutation Counting\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nCalculate the number of permutations p\nof size n with exactly k inversions (pairs of indices (i,j) such that i<j and pi>pj) and exactly x indices i such that pi>pi+1\n\n.\n\nYep, that's the whole problem. Good luck!\nInput\n\nThe first line contains one integer t\n(1≤t≤3⋅104\n\n) — the number of test cases.\n\nEach test case consists of one line which contains three integers n\n, k and x (1≤n≤998244352; 1≤k≤11; 1≤x≤11\n\n).\nOutput\n\nFor each test case, print one integer — the answer to the problem, taken modulo 998244353\n\n.\nExample\nInput\nCopy\n\n5\n10 6 4\n7 3 1\n163316 11 7\n136373 11 1\n325902 11 11\n\nOutput\nCopy\n\n465\n12\n986128624\n7636394\n57118194\n\n"
        }
    ],
    "/contest/1728": [
        {
            "problem": "A",
            "task": "A. Colored Balls: Revisited\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThe title is a reference to the very first Educational Round from our writers team, Educational Round 18.\n\nThere is a bag, containing colored balls. There are n\ndifferent colors of balls, numbered from 1 to n. There are cnti balls of color i in the bag. The total amount of balls in the bag is odd (e. g. cnt1+cnt2+⋯+cntn\n\nis odd).\n\nIn one move, you can choose two balls with different colors and take them out of the bag.\n\nAt some point, all the remaining balls in the bag will have the same color. That's when you can't make moves anymore.\n\nFind any possible color of the remaining balls.\nInput\n\nThe first line contains a single integer t\n(1≤t≤1000\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(1≤n≤20\n\n) — the number of colors.\n\nThe second line contains n\nintegers cnt1,cnt2,…,cntn (1≤cnti≤100\n\n) — the amount of balls of each color in the bag.\n\nThe total amount of balls in the bag is odd (e. g. cnt1+cnt2+⋯+cntn\n\nis odd).\nOutput\n\nFor each testcase, print a single integer — any possible color of the remaining balls, after you made some moves and can't make moves anymore.\nExample\nInput\nCopy\n\n3\n3\n1 1 1\n1\n9\n2\n4 7\n\nOutput\nCopy\n\n3\n1\n2\n\nNote\n\nIn the first testcase, your first and only move can be one of the following:\n\n    take balls with colors 1\n\nand 2\n;\ntake balls with colors 1\nand 3\n;\ntake balls with colors 2\nand 3\n\n    . \n\nAfter the move, exactly one ball will remain. Its color can be 3,2\nor 1\n\ndepending on the move.\n\nIn the second testcase, you can't make moves at all — there is only color of balls already. This color is 1\n\n.\n\nIn the third testcase, you can keep removing one ball of color 1\nand one ball of color 2 until there are no more balls of color 1. At the end, three balls of color 2 remain."
        },
        {
            "problem": "B",
            "task": "B. Best Permutation\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nLet's define the value of the permutation p\nof n integers 1, 2, ..., n (a permutation is an array where each element from 1 to n\n\noccurs exactly once) as follows:\n\n    initially, an integer variable x\n\nis equal to 0\n;\nif x<p1\n, then add p1 to x (set x=x+p1), otherwise assign 0 to x\n;\nif x<p2\n, then add p2 to x (set x=x+p2), otherwise assign 0 to x\n;\n...\nif x<pn\n, then add pn to x (set x=x+pn), otherwise assign 0 to x\n;\nthe value of the permutation is x\n\n    at the end of this process. \n\nFor example, for p=[4,5,1,2,3,6]\n, the value of x changes as follows: 0,4,9,0,2,5,11, so the value of the permutation is 11\n\n.\n\nYou are given an integer n\n. Find a permutation p of size n with the maximum possible value among all permutations of size n\n\n. If there are several such permutations, you can print any of them.\nInput\n\nThe first line contains one integer t\n(1≤t≤97\n\n) — the number of test cases.\n\nThe only line of each test case contains one integer n\n(4≤n≤100\n\n).\nOutput\n\nFor each test case, print n\nintegers — the permutation p of size n with the maximum possible value among all permutations of size n\n\n.\nExample\nInput\nCopy\n\n3\n4\n5\n6\n\nOutput\nCopy\n\n2 1 3 4\n1 2 3 4 5\n4 5 1 2 3 6"
        },
        {
            "problem": "C",
            "task": "C. Digital Logarithm\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nLet's define f(x)\nfor a positive integer x as the length of the base-10 representation of x\n\nwithout leading zeros. I like to call it a digital logarithm. Similar to a digital root, if you are familiar with that.\n\nYou are given two arrays a\nand b, each containing n\n\npositive integers. In one operation, you do the following:\n\n    pick some integer i\n\nfrom 1 to n\n;\nassign either f(ai)\nto ai or f(bi) to bi\n\n    . \n\nTwo arrays are considered similar to each other if you can rearrange the elements in both of them, so that they are equal (e. g. ai=bi\nfor all i from 1 to n\n\n).\n\nWhat's the smallest number of operations required to make a\nand b\n\nsimilar to each other?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of the testcase contains a single integer n\n(1≤n≤2⋅105\n\n) — the number of elements in each of the arrays.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai<109\n\n).\n\nThe third line contains n\nintegers b1,b2,…,bn (1≤bj<109\n\n).\n\nThe sum of n\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print the smallest number of operations required to make a\nand b\n\nsimilar to each other.\nExample\nInput\nCopy\n\n4\n1\n1\n1000\n4\n1 2 3 4\n3 1 4 2\n3\n2 9 3\n1 100 9\n10\n75019 709259 5 611271314 9024533 81871864 9 3 6 4865\n9503 2 371245467 6 7 37376159 8 364036498 52295554 169\n\nOutput\nCopy\n\n2\n0\n2\n18\n\nNote\n\nIn the first testcase, you can apply the digital logarithm to b1\n\ntwice.\n\nIn the second testcase, the arrays are already similar to each other.\n\nIn the third testcase, you can first apply the digital logarithm to a1\n, then to b2."
        },
        {
            "problem": "D",
            "task": "D. Letter Picking\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nAlice and Bob are playing a game. Initially, they are given a non-empty string s\n\n, consisting of lowercase Latin letters. The length of the string is even. Each player also has a string of their own, initially empty.\n\nAlice starts, then they alternate moves. In one move, a player takes either the first or the last letter of the string s\n, removes it from s\n\nand prepends (adds to the beginning) it to their own string.\n\nThe game ends when the string s\n\nbecomes empty. The winner is the player with a lexicographically smaller string. If the players' strings are equal, then it's a draw.\n\nA string a\nis lexicographically smaller than a string b if there exists such position i that aj=bj for all j<i and ai<bi\n\n.\n\nWhat is the result of the game if both players play optimally (e. g. both players try to win; if they can't, then try to draw)?\nInput\n\nThe first line contains a single integer t\n(1≤t≤1000\n\n) — the number of testcases.\n\nEach testcase consists of a single line — a non-empty string s\n, consisting of lowercase Latin letters. The length of the string s\n\nis even.\n\nThe total length of the strings over all testcases doesn't exceed 2000\n\n.\nOutput\n\nFor each testcase, print the result of the game if both players play optimally. If Alice wins, print \"Alice\". If Bob wins, print \"Bob\". If it's a draw, print \"Draw\".\nExample\nInput\nCopy\n\n2\nforces\nabba\n\nOutput\nCopy\n\nAlice\nDraw\n\nNote\n\nOne of the possible games Alice and Bob can play in the first testcase:\n\n    Alice picks the first letter in s\n\n: s=\"orces\", a=\"f\", b=\n\"\";\nBob picks the last letter in s\n: s=\"orce\", a=\"f\", b=\n\"s\";\nAlice picks the last letter in s\n: s=\"orc\", a=\"ef\", b=\n\"s\";\nBob picks the first letter in s\n: s=\"rc\", a=\"ef\", b=\n\"os\";\nAlice picks the last letter in s\n: s=\"r\", a=\"cef\", b=\n\"os\";\nBob picks the remaining letter in s\n: s=\"\", a=\"cef\", b=\n\n    \"ros\". \n\nAlice wins because \"cef\" < \"ros\". Neither of the players follows any strategy in this particular example game, so it doesn't show that Alice wins if both play optimally."
        },
        {
            "problem": "E",
            "task": "E. Red-Black Pepper\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp is going to host a party for his friends. He prepared n\n\ndishes and is about to serve them. First, he has to add some powdered pepper to each of them — otherwise, the dishes will be pretty tasteless.\n\nThe i\n-th dish has two values ai and bi\n\n — its tastiness with red pepper added or black pepper added, respectively. Monocarp won't add both peppers to any dish, won't add any pepper multiple times, and won't leave any dish without the pepper added.\n\nBefore adding the pepper, Monocarp should first purchase the said pepper in some shop. There are m\nshops in his local area. The j-th of them has packages of red pepper sufficient for xj servings and packages of black pepper sufficient for yj\n\nservings.\n\nMonocarp goes to exactly one shop, purchases multiple (possibly, zero) packages of each pepper in such a way that each dish will get the pepper added once, and no pepper is left. More formally, if he purchases x\nred pepper packages and y black pepper packages, then x and y should be non-negative and x⋅xj+y⋅yj should be equal to n\n\n.\n\nFor each shop, determine the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages in the said way, print -1.\nInput\n\nThe first line contains a single integer n\n(1≤n≤3⋅105\n\n) — the number of dishes.\n\nThe i\n-th of the next n lines contains two integers ai and bi (1≤ai,bi≤109) — the tastiness of the i\n\n-th dish with red pepper added or black pepper added, respectively.\n\nThe next line contains a single integer m\n(1≤m≤3⋅105\n\n) — the number of shops.\n\nThe j\n-th of the next m lines contains two integers xj and yj (1≤xj,yj≤n) — the number of servings the red and the black pepper packages are sufficient for in the j\n\n-th shop, respectively.\nOutput\n\nPrint m\n\nintegers. For each shop, print the maximum total tastiness of the dishes after Monocarp buys pepper packages only in this shop and adds the pepper to the dishes. If it's impossible to purchase the packages so that each dish will get the pepper added once and no pepper is left, print -1.\nExamples\nInput\nCopy\n\n3\n5 10\n100 50\n2 2\n4\n2 3\n1 1\n3 2\n2 2\n\nOutput\nCopy\n\n62\n112\n107\n-1\n\nInput\nCopy\n\n10\n3 1\n2 3\n1 1\n2 1\n6 3\n1 4\n4 3\n1 3\n5 3\n5 4\n10\n8 10\n9 3\n1 4\n2 5\n8 3\n3 5\n1 6\n7 2\n6 7\n3 1\n\nOutput\nCopy\n\n26\n-1\n36\n30\n-1\n26\n34\n26\n-1\n36\n\nNote\n\nConsider the first example.\n\nIn the first shop, Monocarp can only buy 0\nred pepper packages and 1 black pepper package. Black pepper added to all dishes will sum up to 10+50+2=62\n\n.\n\nIn the second shop, Monocarp can buy any number of red and black pepper packages: 0\nand 3, 1 and 2, 2 and 1 or 3 and 0. The optimal choice turns out to be either 1 and 2 or 2 and 1. Monocarp can add black pepper to the first dish, red pepper to the second dish and any pepper to the third dish, the total is 10+100+2=112\n\n.\n\nIn the third shop, Monocarp can only buy 1\nred pepper package and 0 black pepper packages. Red pepper added to all dishes will sum up to 5+100+2=107\n\n.\n\nIn the fourth shop, Monocarp can only buy an even total number of packages. Since n\nis odd, it's impossible to get exactly n packages. Thus, the answer is −1."
        },
        {
            "problem": "F",
            "task": "F. Fishermen\ntime limit per test\n6 seconds\nmemory limit per test\n512 megabytes\n\nThere are n\nfishermen who have just returned from a fishing trip. The i-th fisherman has caught a fish of size ai\n\n.\n\nThe fishermen will choose some order in which they are going to tell the size of the fish they caught (the order is just a permutation of size n\n\n). However, they are not entirely honest, and they may \"increase\" the size of the fish they have caught.\n\nFormally, suppose the chosen order of the fishermen is [p1,p2,p3,…,pn]\n. Let bi be the value which the i-th fisherman in the order will tell to the other fishermen. The values bi\n\nare chosen as follows:\n\n    the first fisherman in the order just honestly tells the actual size of the fish he has caught, so b1=ap1\n\n;\nevery other fisherman wants to tell a value that is strictly greater than the value told by the previous fisherman, and is divisible by the size of the fish that the fisherman has caught. So, for i>1\n, bi is the smallest integer that is both strictly greater than bi−1 and divisible by api\n\n    . \n\nFor example, let n=7\n, a=[1,8,2,3,2,2,3]. If the chosen order is p=[1,6,7,5,3,2,4]\n\n, then:\n\n    b1=ap1=1\n\n;\nb2\nis the smallest integer divisible by 2 and greater than 1, which is 2\n;\nb3\nis the smallest integer divisible by 3 and greater than 2, which is 3\n;\nb4\nis the smallest integer divisible by 2 and greater than 3, which is 4\n;\nb5\nis the smallest integer divisible by 2 and greater than 4, which is 6\n;\nb6\nis the smallest integer divisible by 8 and greater than 6, which is 8\n;\nb7\nis the smallest integer divisible by 3 and greater than 8, which is 9\n\n    . \n\nYou have to choose the order of fishermen in a way that yields the minimum possible ∑i=1nbi\n\n.\nInput\n\nThe first line contains one integer n\n(1≤n≤1000\n\n) — the number of fishermen.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤106\n\n).\nOutput\n\nPrint one integer — the minimum possible value of ∑i=1nbi\n\nyou can obtain by choosing the order of fishermen optimally.\nExamples\nInput\nCopy\n\n7\n1 8 2 3 2 2 3\n\nOutput\nCopy\n\n33\n\nInput\nCopy\n\n10\n5 6 5 6 5 6 5 6 5 6\n\nOutput\nCopy\n\n165\n"
        }
    ],
    "/contest/1651": [
        {
            "problem": "A",
            "task": "A. Playoff\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nConsider a playoff tournament where 2n\nathletes compete. The athletes are numbered from 1 to 2n\n\n.\n\nThe tournament is held in n\n\nstages. In each stage, the athletes are split into pairs in such a way that each athlete belongs exactly to one pair. In each pair, the athletes compete against each other, and exactly one of them wins. The winner of each pair advances to the next stage, the athlete who was defeated gets eliminated from the tournament.\n\nThe pairs are formed as follows:\n\n    in the first stage, athlete 1\n\ncompetes against athlete 2; 3 competes against 4; 5 competes against 6\n, and so on;\nin the second stage, the winner of the match \"1\n–2\" competes against the winner of the match \"3–4\"; the winner of the match \"5–6\" competes against the winner of the match \"7–8\n\n    \", and so on;\n    the next stages are held according to the same rules. \n\nWhen athletes x\nand y\n\ncompete, the winner is decided as follows:\n\n    if x+y\n\nis odd, the athlete with the lower index wins (i. e. if x<y, then x wins, otherwise y\nwins);\nif x+y\n\n    is even, the athlete with the higher index wins. \n\nThe following picture describes the way the tournament with n=3\n\ngoes.\n\nYour task is the following one: given the integer n\n\n, determine the index of the athlete who wins the tournament.\nInput\n\nThe first line contains one integer t\n(1≤t≤30\n\n) — the number of test cases.\n\nEach test case consists of one line containing one integer n\n(1≤n≤30\n\n).\nOutput\n\nFor each test case, print one integer — the index of the winner of the tournament.\nExample\nInput\nCopy\n\n2\n3\n1\n\nOutput\nCopy\n\n7\n1\n\nNote\n\nThe case n=3\n\nis shown in the picture from the statement.\n\nIf n=1\n, then there's only one match between athletes 1 and 2. Since 1+2=3 is an odd number, the athlete with the lower index wins. So, the athlete 1 is the winner."
        },
        {
            "problem": "B",
            "task": "B. Prove Him Wrong\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nRecently, your friend discovered one special operation on an integer array a\n\n:\n\n    Choose two indices i\n\nand j (i≠j\n);\nSet ai=aj=|ai−aj|\n\n    . \n\nAfter playing with this operation for a while, he came to the next conclusion:\n\n    For every array a\n\nof n integers, where 1≤ai≤109, you can find a pair of indices (i,j) such that the total sum of a\n\n    will decrease after performing the operation. \n\nThis statement sounds fishy to you, so you want to find a counterexample for a given integer n\n\n. Can you find such counterexample and prove him wrong?\n\nIn other words, find an array a\nconsisting of n integers a1,a2,…,an (1≤ai≤109) such that for all pairs of indices (i,j)\n\nperforming the operation won't decrease the total sum (it will increase or not change the sum).\nInput\n\nThe first line contains a single integer t\n(1≤t≤100) — the number of test cases. Then t\n\ntest cases follow.\n\nThe first and only line of each test case contains a single integer n\n(2≤n≤1000) — the length of array a\n\n.\nOutput\n\nFor each test case, if there is no counterexample array a\nof size n\n\n, print NO.\n\nOtherwise, print YES followed by the array a\nitself (1≤ai≤109\n\n). If there are multiple counterexamples, print any.\nExample\nInput\nCopy\n\n3\n2\n512\n3\n\nOutput\nCopy\n\nYES\n1 337\nNO\nYES\n31 4 159\n\nNote\n\nIn the first test case, the only possible pairs of indices are (1,2)\nand (2,1)\n\n.\n\nIf you perform the operation on indices (1,2)\n(or (2,1)), you'll get a1=a2=|1−337|=336, or array [336,336]. In both cases, the total sum increases, so this array a is a counterexample."
        },
        {
            "problem": "C",
            "task": "C. Fault-tolerant Network\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere is a classroom with two rows of computers. There are n\ncomputers in each row and each computer has its own grade. Computers in the first row has grades a1,a2,…,an and in the second row — b1,b2,…,bn\n\n.\n\nInitially, all pairs of neighboring computers in each row are connected by wire (pairs (i,i+1)\nfor all 1≤i<n\n\n), so two rows form two independent computer networks.\n\nYour task is to combine them in one common network by connecting one or more pairs of computers from different rows. Connecting the i\n-th computer from the first row and the j-th computer from the second row costs |ai−bj|\n\n.\n\nYou can connect one computer to several other computers, but you need to provide at least a basic fault tolerance: you need to connect computers in such a way that the network stays connected, despite one of its computer failing. In other words, if one computer is broken (no matter which one), the network won't split in two or more parts.\n\nThat is the minimum total cost to make a fault-tolerant network?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104) — the number of test cases. Next t\n\ncases follow.\n\nThe first line of each test case contains the single integer n\n(3≤n≤2⋅105\n\n) — the number of computers in each row.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤109\n\n) — the grades of computers in the first row.\n\nThe third line contains n\nintegers b1,b2,…,bn (1≤bi≤109\n\n) — the grades of computers in the second row.\n\nIt's guaranteed that the total sum of n\ndoesn't exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print a single integer — the minimum total cost to make a fault-tolerant network.\nExample\nInput\nCopy\n\n2\n3\n1 10 1\n20 4 25\n4\n1 1 1 1\n1000000000 1000000000 1000000000 1000000000\n\nOutput\nCopy\n\n31\n1999999998\n\nNote\n\nIn the first test case, it's optimal to connect four pairs of computers:\n\n    computer 1\n\nfrom the first row with computer 2 from the second row: cost |1−4|=3\n;\ncomputer 3\nfrom the first row with computer 2 from the second row: cost |1−4|=3\n;\ncomputer 2\nfrom the first row with computer 1 from the second row: cost |10−20|=10\n;\ncomputer 2\nfrom the first row with computer 3 from the second row: cost |10−25|=15\n\n    ; \n\nIn total, 3+3+10+15=31.\n\nIn the second test case, it's optimal to connect 1\nfrom the first row with 1 from the second row, and 4 from the first row with 4 from the second row."
        },
        {
            "problem": "D",
            "task": "D. Nearest Excluded Points\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nYou are given n\ndistinct points on a plane. The coordinates of the i-th point are (xi,yi)\n\n.\n\nFor each point i\n, find the nearest (in terms of Manhattan distance) point with integer coordinates that is not among the given n\n\npoints. If there are multiple such points — you can choose any of them.\n\nThe Manhattan distance between two points (x1,y1)\nand (x2,y2) is |x1−x2|+|y1−y2|\n\n.\nInput\n\nThe first line of the input contains one integer n\n(1≤n≤2⋅105\n\n) — the number of points in the set.\n\nThe next n\nlines describe points. The i-th of them contains two integers xi and yi (1≤xi,yi≤2⋅105) — coordinates of the i\n\n-th point.\n\nIt is guaranteed that all points in the input are distinct.\nOutput\n\nPrint n\nlines. In the i-th line, print the point with integer coordinates that is not among the given n points and is the nearest (in terms of Manhattan distance) to the i\n\n-th point from the input.\n\nOutput coordinates should be in range [−106;106]\n\n. It can be shown that any optimal answer meets these constraints.\n\nIf there are several answers, you can print any of them.\nExamples\nInput\nCopy\n\n6\n2 2\n1 2\n2 1\n3 2\n2 3\n5 5\n\nOutput\nCopy\n\n1 1\n1 1\n2 0\n3 1\n2 4\n5 4\n\nInput\nCopy\n\n8\n4 4\n2 4\n2 2\n2 3\n1 4\n4 2\n1 3\n3 3\n\nOutput\nCopy\n\n4 3\n2 5\n2 1\n2 5\n1 5\n4 1\n1 2\n3 2\n"
        },
        {
            "problem": "E",
            "task": "E. Sum of Matchings\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nLet's denote the size of the maximum matching in a graph G\nas MM(G)\n\n.\n\nYou are given a bipartite graph. The vertices of the first part are numbered from 1\nto n, the vertices of the second part are numbered from n+1 to 2n. Each vertex's degree is 2\n\n.\n\nFor a tuple of four integers (l,r,L,R)\n, where 1≤l≤r≤n and n+1≤L≤R≤2n, let's define G′(l,r,L,R) as the graph which consists of all vertices of the given graph that are included in the segment [l,r] or in the segment [L,R], and all edges of the given graph such that each of their endpoints belongs to one of these segments. In other words, to obtain G′(l,r,L,R) from the original graph, you have to remove all vertices i such that i∉[l,r] and i∉[L,R]\n\n, and all edges incident to these vertices.\n\nCalculate the sum of MM(G(l,r,L,R))\nover all tuples of integers (l,r,L,R) having 1≤l≤r≤n and n+1≤L≤R≤2n\n\n.\nInput\n\nThe first line contains one integer n\n(2≤n≤1500\n\n) — the number of vertices in each part.\n\nThen 2n\nlines follow, each denoting an edge of the graph. The i-th line contains two integers xi and yi (1≤xi≤n; n+1≤yi≤2n) — the endpoints of the i\n\n-th edge.\n\nThere are no multiple edges in the given graph, and each vertex has exactly two incident edges.\nOutput\n\nPrint one integer — the sum of MM(G(l,r,L,R))\nover all tuples of integers (l,r,L,R) having 1≤l≤r≤n and n+1≤L≤R≤2n\n\n.\nExample\nInput\nCopy\n\n5\n4 6\n4 9\n2 6\n3 9\n1 8\n5 10\n2 7\n3 7\n1 10\n5 8\n\nOutput\nCopy\n\n314\n"
        },
        {
            "problem": "F",
            "task": "F. Tower Defense\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nMonocarp is playing a tower defense game. A level in the game can be represented as an OX axis, where each lattice point from 1\nto n\n\ncontains a tower in it.\n\nThe tower in the i\n-th point has ci mana capacity and ri mana regeneration rate. In the beginning, before the 0-th second, each tower has full mana. If, at the end of some second, the i-th tower has x mana, then it becomes min(x+ri,ci)\n\nmana for the next second.\n\nThere are q\nmonsters spawning on a level. The j-th monster spawns at point 1 at the beginning of tj-th second, and it has hj health. Every monster is moving 1\n\npoint per second in the direction of increasing coordinate.\n\nWhen a monster passes the tower, the tower deals min(H,M)\ndamage to it, where H is the current health of the monster and M\n\nis the current mana amount of the tower. This amount gets subtracted from both monster's health and tower's mana.\n\nUnfortunately, sometimes some monsters can pass all n\n\ntowers and remain alive. Monocarp wants to know what will be the total health of the monsters after they pass all towers.\nInput\n\nThe first line contains a single integer n\n(1≤n≤2⋅105\n\n) — the number of towers.\n\nThe i\n-th of the next n lines contains two integers ci and ri (1≤ri≤ci≤109) — the mana capacity and the mana regeneration rate of the i\n\n-th tower.\n\nThe next line contains a single integer q\n(1≤q≤2⋅105\n\n) — the number of monsters.\n\nThe j\n-th of the next q lines contains two integers tj and hj (0≤tj≤2⋅105; 1≤hj≤1012) — the time the j\n\n-th monster spawns and its health.\n\nThe monsters are listed in the increasing order of their spawn time, so tj<tj+1\nfor all 1≤j≤q−1\n\n.\nOutput\n\nPrint a single integer — the total health of all monsters after they pass all towers.\nExamples\nInput\nCopy\n\n3\n5 1\n7 4\n4 2\n4\n0 14\n1 10\n3 16\n10 16\n\nOutput\nCopy\n\n4\n\nInput\nCopy\n\n5\n2 1\n4 1\n5 4\n7 5\n8 3\n9\n1 21\n2 18\n3 14\n4 24\n5 8\n6 25\n7 19\n8 24\n9 24\n\nOutput\nCopy\n\n40\n"
        }
    ],
    "/contest/1716": [
        {
            "problem": "A",
            "task": "A. 2-3 Moves\ntime limit per test\n1 second\nmemory limit per test\n256 megabytes\n\nYou are standing at the point 0\non a coordinate line. Your goal is to reach the point n. In one minute, you can move by 2 or by 3 to the left or to the right (i. e., if your current coordinate is x, it can become x−3, x−2, x+2 or x+3\n\n). Note that the new coordinate can become negative.\n\nYour task is to find the minimum number of minutes required to get from the point 0\nto the point n\n\n.\n\nYou have to answer t\n\nindependent test cases.\nInput\n\nThe first line of the input contains one integer t\n(1≤t≤104) — the number of test cases. Then t\n\nlines describing the test cases follow.\n\nThe i\n-th of these lines contains one integer n (1≤n≤109) — the goal of the i\n\n-th test case.\nOutput\n\nFor each test case, print one integer — the minimum number of minutes required to get from the point 0\nto the point n\n\nfor the corresponding test case.\nExample\nInput\nCopy\n\n4\n1\n3\n4\n12\n\nOutput\nCopy\n\n2\n1\n2\n4\n\n"
        },
        {
            "problem": "B",
            "task": "B. Permutation Chain\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nA permutation of length n\nis a sequence of integers from 1 to n\n\nsuch that each integer appears in it exactly once.\n\nLet the fixedness of a permutation p\nbe the number of fixed points in it — the number of positions j such that pj=j, where pj is the j-th element of the permutation p\n\n.\n\nYou are asked to build a sequence of permutations a1,a2,…\n, starting from the identity permutation (permutation a1=[1,2,…,n]). Let's call it a permutation chain. Thus, ai is the i-th permutation of length n\n\n.\n\nFor every i\nfrom 2 onwards, the permutation ai should be obtained from the permutation ai−1 by swapping any two elements in it (not necessarily neighboring). The fixedness of the permutation ai should be strictly lower than the fixedness of the permutation ai−1\n\n.\n\nConsider some chains for n=3\n\n:\n\n    a1=[1,2,3]\n\n, a2=[1,3,2] — that is a valid chain of length 2. From a1 to a2, the elements on positions 2 and 3 get swapped, the fixedness decrease from 3 to 1\n.\na1=[2,1,3]\n, a2=[3,1,2] — that is not a valid chain. The first permutation should always be [1,2,3] for n=3\n.\na1=[1,2,3]\n, a2=[1,3,2], a3=[1,2,3] — that is not a valid chain. From a2 to a3, the elements on positions 2 and 3 get swapped but the fixedness increase from 1 to 3\n.\na1=[1,2,3]\n, a2=[3,2,1], a3=[3,1,2] — that is a valid chain of length 3. From a1 to a2, the elements on positions 1 and 3 get swapped, the fixedness decrease from 3 to 1. From a2 to a3, the elements on positions 2 and 3 get swapped, the fixedness decrease from 1 to 0\n\n    . \n\nFind the longest permutation chain. If there are multiple longest answers, print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤99\n\n) — the number of testcases.\n\nThe only line of each testcase contains a single integer n\n(2≤n≤100\n\n) — the required length of permutations in the chain.\nOutput\n\nFor each testcase, first, print the length of a permutation chain k\n\n.\n\nThen print k\npermutations a1,a2,…,ak. a1 should be an identity permutation of length n ([1,2,…,n]). For each i from 2 to k, ai should be obtained by swapping two elements in ai−1. It should also have a strictly lower fixedness than ai−1\n\n.\nExample\nInput\nCopy\n\n2\n2\n3\n\nOutput\nCopy\n\n2\n1 2\n2 1\n3\n1 2 3\n3 2 1\n3 1 2\n"
        },
        {
            "problem": "C",
            "task": "C. Robot in a Hallway\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere is a grid, consisting of 2\nrows and m columns. The rows are numbered from 1 to 2 from top to bottom. The columns are numbered from 1 to m\n\nfrom left to right.\n\nThe robot starts in a cell (1,1)\n\n. In one second, it can perform either of two actions:\n\n    move into a cell adjacent by a side: up, right, down or left;\n    remain in the same cell. \n\nThe robot is not allowed to move outside the grid.\n\nInitially, all cells, except for the cell (1,1)\n, are locked. Each cell (i,j) contains a value ai,j — the moment that this cell gets unlocked. The robot can only move into a cell (i,j) if at least ai,j\n\nseconds have passed before the move.\n\nThe robot should visit all cells without entering any cell twice or more (cell (1,1)\n\nis considered entered at the start). It can finish in any cell.\n\nWhat is the fastest the robot can achieve that?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer m\n(2≤m≤2⋅105\n\n) — the number of columns of the grid.\n\nThe i\n-th of the next 2 lines contains m integers ai,1,ai,2,…,ai,m (0≤ai,j≤109) — the moment of time each cell gets unlocked. a1,1=0. If ai,j=0, then cell (i,j)\n\nis unlocked from the start.\n\nThe sum of m\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the minimum amount of seconds that the robot can take to visit all cells without entering any cell twice or more.\nExample\nInput\nCopy\n\n4\n3\n0 0 1\n4 3 2\n5\n0 4 8 12 16\n2 6 10 14 18\n4\n0 10 10 10\n10 10 10 10\n2\n0 0\n0 0\n\nOutput\nCopy\n\n5\n19\n17\n3\n"
        },
        {
            "problem": "D",
            "task": "D. Chip Move\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere is a chip on the coordinate line. Initially, the chip is located at the point 0\n. You can perform any number of moves; each move increases the coordinate of the chip by some positive integer (which is called the length of the move). The length of the first move you make should be divisible by k, the length of the second move — by k+1, the third — by k+2\n\n, and so on.\n\nFor example, if k=2\n, then the sequence of moves may look like this: 0→4→7→19→44, because 4−0=4 is divisible by 2=k, 7−4=3 is divisible by 3=k+1, 19−7=12 is divisible by 4=k+2, 44−19=25 is divisible by 5=k+3\n\n.\n\nYou are given two positive integers n\nand k. Your task is to count the number of ways to reach the point x, starting from 0, for every x∈[1,n]. The number of ways can be very large, so print it modulo 998244353\n\n. Two ways are considered different if they differ as sets of visited positions.\nInput\n\nThe first (and only) line of the input contains two integers n\nand k (1≤k≤n≤2⋅105\n\n).\nOutput\n\nPrint n\nintegers — the number of ways to reach the point x, starting from 0, for every x∈[1,n], taken modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n8 1\n\nOutput\nCopy\n\n1 1 2 2 3 4 5 6 \n\nInput\nCopy\n\n10 2\n\nOutput\nCopy\n\n0 1 0 1 1 1 1 2 2 2 \n\nNote\n\nLet's look at the first example:\n\nWays to reach the point 1\n: [0,1]\n\n;\n\nWays to reach the point 2\n: [0,2]\n\n;\n\nWays to reach the point 3\n: [0,1,3], [0,3]\n\n;\n\nWays to reach the point 4\n: [0,2,4], [0,4]\n\n;\n\nWays to reach the point 5\n: [0,1,5], [0,3,5], [0,5]\n\n;\n\nWays to reach the point 6\n: [0,1,3,6], [0,2,6], [0,4,6], [0,6]\n\n;\n\nWays to reach the point 7\n: [0,2,4,7], [0,1,7], [0,3,7], [0,5,7], [0,7]\n\n;\n\nWays to reach the point 8\n: [0,3,5,8], [0,1,5,8], [0,2,8], [0,4,8], [0,6,8], [0,8]\n\n.\n\n"
        },
        {
            "problem": "E",
            "task": "E. Swap and Maximum Block\ntime limit per test\n4 seconds\nmemory limit per test\n512 megabytes\n\nYou are given an array of length 2n\n. The elements of the array are numbered from 1 to 2n\n\n.\n\nYou have to process q\nqueries to this array. In the i-th query, you will be given an integer k (0≤k≤n−1\n\n). To process the query, you should do the following:\n\n    for every i∈[1,2n−2k]\n\nin ascending order, do the following: if the i-th element was already swapped with some other element during this query, skip it; otherwise, swap ai and ai+2k\n\n    ;\n    after that, print the maximum sum over all contiguous subsegments of the array (including the empty subsegment). \n\nFor example, if the array a\nis [−3,5,−3,2,8,−20,6,−1], and k=1\n\n, the query is processed as follows:\n\n    the 1\n\n-st element wasn't swapped yet, so we swap it with the 3\n-rd element;\nthe 2\n-nd element wasn't swapped yet, so we swap it with the 4\n-th element;\nthe 3\n-rd element was swapped already;\nthe 4\n-th element was swapped already;\nthe 5\n-th element wasn't swapped yet, so we swap it with the 7\n-th element;\nthe 6\n-th element wasn't swapped yet, so we swap it with the 8\n\n    -th element. \n\nSo, the array becomes [−3,2,−3,5,6,−1,8,−20]\n. The subsegment with the maximum sum is [5,6,−1,8], and the answer to the query is 18\n\n.\n\nNote that the queries actually change the array, i. e. after a query is performed, the array does not return to its original state, and the next query will be applied to the modified array.\nInput\n\nThe first line contains one integer n\n(1≤n≤18\n\n).\n\nThe second line contains 2n\nintegers a1,a2,…,a2n (−109≤ai≤109\n\n).\n\nThe third line contains one integer q\n(1≤q≤2⋅105\n\n).\n\nThen q\nlines follow, the i-th of them contains one integer k (0≤k≤n−1) describing the i\n\n-th query.\nOutput\n\nFor each query, print one integer — the maximum sum over all contiguous subsegments of the array (including the empty subsegment) after processing the query.\nExample\nInput\nCopy\n\n3\n-3 5 -3 2 8 -20 6 -1\n3\n1\n0\n1\n\nOutput\nCopy\n\n18\n8\n13\n\nNote\n\nTransformation of the array in the example: [−3,5,−3,2,8,−20,6,−1]→[−3,2,−3,5,6,−1,8,−20]→[2,−3,5,−3,−1,6,−20,8]→[5,−3,2,−3,−20,8,−1,6]\n."
        },
        {
            "problem": "F",
            "task": "F. Bags with Balls\ntime limit per test\n3 seconds\nmemory limit per test\n512 megabytes\n\nThere are n\nbags, each bag contains m balls with numbers from 1 to m. For every i∈[1,m], there is exactly one ball with number i\n\nin each bag.\n\nYou have to take exactly one ball from each bag (all bags are different, so, for example, taking the ball 1\nfrom the first bag and the ball 2 from the second bag is not the same as taking the ball 2 from the first bag and the ball 1 from the second bag). After that, you calculate the number of balls with odd numbers among the ones you have taken. Let the number of these balls be F\n\n.\n\nYour task is to calculate the sum of Fk\nover all possible ways to take n\n\nballs, one from each bag.\nInput\n\nThe first line contains one integer t\n(1≤t≤5000\n\n) — the number of test cases.\n\nEach test case consists of one line containing three integers n\n, m and k (1≤n,m≤998244352; 1≤k≤2000\n\n).\nOutput\n\nFor each test case, print one integer — the sum of Fk\nover all possible ways to take n balls, one from each bag. Since it can be huge, print it modulo 998244353\n\n.\nExample\nInput\nCopy\n\n5\n2 3 8\n1 1 1\n1 5 10\n3 7 2000\n1337666 42424242 2000\n\nOutput\nCopy\n\n1028\n1\n3\n729229716\n652219904\n"
        }
    ],
    "/contest/1681": [
        {
            "problem": "A",
            "task": "A. Game with Cards\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nAlice and Bob play a game. Alice has n\ncards, the i-th of them has the integer ai written on it. Bob has m cards, the j-th of them has the integer bj\n\nwritten on it.\n\nOn the first turn of the game, the first player chooses one of his/her cards and puts it on the table (plays it). On the second turn, the second player chooses one of his/her cards such that the integer on it is greater than the integer on the card played on the first turn, and plays it. On the third turn, the first player chooses one of his/her cards such that the integer on it is greater than the integer on the card played on the second turn, and plays it, and so on — the players take turns, and each player has to choose one of his/her cards with greater integer than the card played by the other player on the last turn.\n\nIf some player cannot make a turn, he/she loses.\n\nFor example, if Alice has 4\ncards with numbers [10,5,3,8], and Bob has 3 cards with numbers [6,11,6]\n\n, the game may go as follows:\n\n    Alice can choose any of her cards. She chooses the card with integer 5\n\nand plays it.\nBob can choose any of his cards with number greater than 5\n. He chooses a card with integer 6\nand plays it.\nAlice can choose any of her cards with number greater than 6\n. She chooses the card with integer 10\nand plays it.\nBob can choose any of his cards with number greater than 10\n. He chooses a card with integer 11\nand plays it.\nAlice can choose any of her cards with number greater than 11\n\n    , but she has no such cards, so she loses. \n\nBoth Alice and Bob play optimally (if a player is able to win the game no matter how the other player plays, the former player will definitely win the game).\n\nYou have to answer two questions:\n\n    who wins if Alice is the first player?\n    who wins if Bob is the first player? \n\nInput\n\nThe first line contains one integer t\n(1≤t≤1000\n\n) — the number of test cases. Each test case consists of four lines.\n\nThe first line of a test case contains one integer n\n(1≤n≤50\n\n) — the number of cards Alice has.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤50\n\n) — the numbers written on the cards that Alice has.\n\nThe third line contains one integer m\n(1≤m≤50\n\n) — the number of Bob's cards.\n\nThe fourth line contains m\nintegers b1,b2,…,bm (1≤bi≤50\n\n) — the numbers on Bob's cards.\nOutput\n\nFor each test case, print two lines. The first line should be Alice if Alice wins when she is the first player; otherwise, the first line should be Bob. The second line should contain the name of the winner if Bob is the first player, in the same format.\nExample\nInput\nCopy\n\n4\n1\n6\n2\n6 8\n4\n1 3 3 7\n2\n4 2\n1\n50\n2\n25 50\n10\n1 2 3 4 5 6 7 8 9 10\n2\n5 15\n\nOutput\nCopy\n\nBob\nBob\nAlice\nAlice\nAlice\nBob\nBob\nBob\n\nNote\n\nLet's consider the first test case of the example.\n\nAlice has one card with integer 6\n, Bob has two cards with numbers [6,8]\n\n.\n\nIf Alice is the first player, she has to play the card with number 6\n. Bob then has to play the card with number 8\n\n. Alice has no cards left, so she loses.\n\nIf Bob is the first player, then no matter which of his cards he chooses on the first turn, Alice won't be able to play her card on the second turn, so she will lose."
        },
        {
            "problem": "B",
            "task": "B. Card Trick\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp has just learned a new card trick, and can't wait to present it to you. He shows you the entire deck of n\ncards. You see that the values of cards from the topmost to the bottommost are integers a1,a2,…,an\n\n, and all values are different.\n\nThen he asks you to shuffle the deck m\ntimes. With the j-th shuffle, you should take bj topmost cards and move them under the remaining (n−bj)\n\ncards without changing the order.\n\nAnd then, using some magic, Monocarp tells you the topmost card of the deck. However, you are not really buying that magic. You tell him that you know the topmost card yourself. Can you surprise Monocarp and tell him the topmost card before he shows it?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(2≤n≤2⋅105\n\n) — the number of cards in the deck.\n\nThe second line contains n\npairwise distinct integers a1,a2,…,an (1≤ai≤n\n\n) — the values of the cards.\n\nThe third line contains a single integer m\n(1≤m≤2⋅105\n\n) — the number of shuffles.\n\nThe fourth line contains m\nintegers b1,b2,…,bm (1≤bj≤n−1) — the amount of cards that are moved on the j\n\n-th shuffle.\n\nThe sum of n\nover all testcases doesn't exceed 2⋅105. The sum of m over all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the value of the card on the top of the deck after the deck is shuffled m\n\ntimes.\nExample\nInput\nCopy\n\n3\n2\n1 2\n3\n1 1 1\n4\n3 1 4 2\n2\n3 1\n5\n2 1 5 4 3\n5\n3 2 1 2 1\n\nOutput\nCopy\n\n2\n3\n3\n\nNote\n\nIn the first testcase, each shuffle effectively swaps two cards. After three swaps, the deck will be [2,1]\n\n.\n\nIn the second testcase, the second shuffle cancels what the first shuffle did. First, three topmost cards went underneath the last card, then that card went back below the remaining three cards. So the deck remained unchanged from the initial one — the topmost card has value 3\n."
        },
        {
            "problem": "C",
            "task": "C. Double Sort\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given two arrays a\nand b, both consisting of n\n\nintegers.\n\nIn one move, you can choose two indices i\nand j (1≤i,j≤n; i≠j) and swap ai with aj and bi with bj\n\n. You have to perform the swap in both arrays.\n\nYou are allowed to perform at most 104\n\nmoves (possibly, zero). Can you make both arrays sorted in a non-decreasing order at the end? If you can, print any sequence of moves that makes both arrays sorted.\nInput\n\nThe first line contains a single integer t\n(1≤t≤100\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(2≤n≤100\n\n) — the number of elements in both arrays.\n\nThe second line contains n\nintegers a1,a2,…,an (1≤ai≤n\n\n) — the first array.\n\nThe third line contains n\nintegers b1,b2,…,bn (1≤bi≤n\n\n) — the second array.\nOutput\n\nFor each testcase, print the answer. If it's impossible to make both arrays sorted in a non-decreasing order in at most 104\nmoves, print -1. Otherwise, first, print the number of moves k (0≤k≤104). Then print i and j for each move (1≤i,j≤n; i≠j)\n\n.\n\nIf there are multiple answers, then print any of them. You don't have to minimize the number of moves.\nExample\nInput\nCopy\n\n3\n2\n1 2\n1 2\n2\n2 1\n1 2\n4\n2 3 1 2\n2 3 2 3\n\nOutput\nCopy\n\n0\n-1\n3\n3 1\n3 2\n4 3\n"
        },
        {
            "problem": "D",
            "task": "D. Required Length\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given two integer numbers, n\nand x. You may perform several operations with the integer x\n\n.\n\nEach operation you perform is the following one: choose any digit y\nthat occurs in the decimal representation of x at least once, and replace x by x⋅y\n\n.\n\nYou want to make the length of decimal representation of x\n(without leading zeroes) equal to n\n\n. What is the minimum number of operations required to do that?\nInput\n\nThe only line of the input contains two integers n\nand x (2≤n≤19; 1≤x<10n−1\n\n).\nOutput\n\nPrint one integer — the minimum number of operations required to make the length of decimal representation of x\n(without leading zeroes) equal to n, or −1\n\nif it is impossible.\nExamples\nInput\nCopy\n\n2 1\n\nOutput\nCopy\n\n-1\n\nInput\nCopy\n\n3 2\n\nOutput\nCopy\n\n4\n\nInput\nCopy\n\n13 42\n\nOutput\nCopy\n\n12\n\nNote\n\nIn the second example, the following sequence of operations achieves the goal:\n\n    multiply x\n\nby 2, so x=2⋅2=4\n;\nmultiply x\nby 4, so x=4⋅4=16\n;\nmultiply x\nby 6, so x=16⋅6=96\n;\nmultiply x\nby 9, so x=96⋅9=864\n\n    . \n\n"
        },
        {
            "problem": "E",
            "task": "E. Labyrinth Adventures\ntime limit per test\n6 seconds\nmemory limit per test\n512 megabytes\n\nYou found a map of a weirdly shaped labyrinth. The map is a grid, consisting of n\nrows and n columns. The rows of the grid are numbered from 1 to n from bottom to top. The columns of the grid are numbered from 1 to n\n\nfrom left to right.\n\nThe labyrinth has n\nlayers. The first layer is the bottom left corner (cell (1,1)\n\n). The second layer consists of all cells that are in the grid and adjacent to the first layer by a side or a corner. The third layer consists of all cells that are in the grid and adjacent to the second layer by a side or a corner. And so on.\n\nThe labyrinth with 5\n\nlayers, for example, is shaped as follows:\n\nThe layers are separated from one another with walls. However, there are doors in these walls.\n\nEach layer (except for layer n\n) has exactly two doors to the next layer. One door is placed on the top wall of the layer and another door is placed on the right wall of the layer. For each layer from 1 to n−1 you are given positions of these two doors. The doors can be passed in both directions: either from layer i to layer i+1 or from layer i+1 to layer i\n\n.\n\nIf you are standing in some cell, you can move to an adjacent by a side cell if a wall doesn't block your move (e.g. you can't move to a cell in another layer if there is no door between the cells).\n\nNow you have m\nqueries of sort: what's the minimum number of moves one has to make to go from cell (x1,y1) to cell (x2,y2)\n\n.\nInput\n\nThe first line contains a single integer n\n(2≤n≤105\n\n) — the number of layers in the labyrinth.\n\nThe i\n-th of the next n−1 lines contains four integers d1,x,d1,y,d2,x and d2,y (1≤d1,x,d1,y,d2,x,d2,y≤n) — the coordinates of the doors. Both cells are on the i-th layer. The first cell is adjacent to the top wall of the i-th layer by a side — that side is where the door is. The second cell is adjacent to the right wall of the i\n\n-th layer by a side — that side is where the door is.\n\nThe next line contains a single integer m\n(1≤m≤2⋅105\n\n) — the number of queries.\n\nThe j\n-th of the next m lines contains four integers x1,y1,x2 and y2 (1≤x1,y1,x2,y2≤n) — the coordinates of the cells in the j\n\n-th query.\nOutput\n\nFor each query, print a single integer — the minimum number of moves one has to make to go from cell (x1,y1)\nto cell (x2,y2)\n\n.\nExamples\nInput\nCopy\n\n2\n1 1 1 1\n10\n1 1 1 1\n1 1 1 2\n1 1 2 1\n1 1 2 2\n1 2 1 2\n1 2 2 1\n1 2 2 2\n2 1 2 1\n2 1 2 2\n2 2 2 2\n\nOutput\nCopy\n\n0\n1\n1\n2\n0\n2\n1\n0\n1\n0\n\nInput\nCopy\n\n4\n1 1 1 1\n2 1 2 2\n3 2 1 3\n5\n2 4 4 3\n4 4 3 3\n1 2 3 3\n2 2 4 4\n1 4 2 3\n\nOutput\nCopy\n\n3\n4\n3\n6\n2\n\nNote\n\nHere is the map of the labyrinth from the second example. The doors are marked red."
        },
        {
            "problem": "F",
            "task": "F. Unique Occurrences\ntime limit per test\n6 seconds\nmemory limit per test\n1024 megabytes\n\nYou are given a tree, consisting of n\n\nvertices. Each edge has an integer value written on it.\n\nLet f(v,u)\nbe the number of values that appear exactly once on the edges of a simple path between vertices v and u\n\n.\n\nCalculate the sum of f(v,u)\nover all pairs of vertices v and u such that 1≤v<u≤n\n\n.\nInput\n\nThe first line contains a single integer n\n(2≤n≤5⋅105\n\n) — the number of vertices in the tree.\n\nEach of the next n−1\nlines contains three integers v,u and x (1≤v,u,x≤n\n\n) — the description of an edge: the vertices it connects and the value written on it.\n\nThe given edges form a tree.\nOutput\n\nPrint a single integer — the sum of f(v,u)\nover all pairs of vertices v and u such that v<u\n\n.\nExamples\nInput\nCopy\n\n3\n1 2 1\n1 3 2\n\nOutput\nCopy\n\n4\n\nInput\nCopy\n\n3\n1 2 2\n1 3 2\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n5\n1 4 4\n1 2 3\n3 4 4\n4 5 5\n\nOutput\nCopy\n\n14\n\nInput\nCopy\n\n2\n2 1 1\n\nOutput\nCopy\n\n1\n\nInput\nCopy\n\n10\n10 2 3\n3 8 8\n4 8 9\n5 8 5\n3 10 7\n7 8 2\n5 6 6\n9 3 4\n1 6 3\n\nOutput\nCopy\n\n120\n"
        }
    ],
    "/contest/1622": [
        {
            "problem": "A",
            "task": "A. Construct a Rectangle\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere are three sticks with integer lengths l1,l2\nand l3\n\n.\n\nYou are asked to break exactly one of them into two pieces in such a way that:\n\n    both pieces have positive (strictly greater than 0\n\n    ) integer length;\n    the total length of the pieces is equal to the original length of the stick;\n    it's possible to construct a rectangle from the resulting four sticks such that each stick is used as exactly one of its sides. \n\nA square is also considered a rectangle.\n\nDetermine if it's possible to do that.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe only line of each testcase contains three integers l1,l2,l3\n(1≤li≤108\n\n) — the lengths of the sticks.\nOutput\n\nFor each testcase, print \"YES\" if it's possible to break one of the sticks into two pieces with positive integer length in such a way that it's possible to construct a rectangle from the resulting four sticks. Otherwise, print \"NO\".\n\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as a positive answer).\nExample\nInput\nCopy\n\n4\n6 1 5\n2 5 2\n2 4 2\n5 5 4\n\nOutput\nCopy\n\nYES\nNO\nYES\nYES\n\nNote\n\nIn the first testcase, the first stick can be broken into parts of length 1\nand 5. We can construct a rectangle with opposite sides of length 1 and 5\n\n.\n\nIn the second testcase, breaking the stick of length 2\ncan only result in sticks of lengths 1,1,2,5, which can't be made into a rectangle. Breaking the stick of length 5 can produce results 2,3 or 1,4\n\nbut neither of them can't be put into a rectangle.\n\nIn the third testcase, the second stick can be broken into parts of length 2\nand 2. The resulting rectangle has opposite sides 2 and 2\n\n(which is a square).\n\nIn the fourth testcase, the third stick can be broken into parts of length 2\nand 2. The resulting rectangle has opposite sides 2 and 5\n\n.\n\n"
        },
        {
            "problem": "B",
            "task": "B. Berland Music\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nBerland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\n\nSo imagine Monocarp got recommended n\nsongs, numbered from 1 to n. The i-th song had its predicted rating equal to pi, where 1≤pi≤n and every integer from 1 to n appears exactly once. In other words, p\n\nis a permutation.\n\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s\n, such that si=0 means that he disliked the i-th song, and si=1\n\nmeans that he liked it.\n\nNow the service has to re-evaluate the song ratings in such a way that:\n\n    the new ratings q1,q2,…,qn\n\nstill form a permutation (1≤qi≤n; each integer from 1 to n\nappears exactly once);\nevery song that Monocarp liked should have a greater rating than every song that Monocarp disliked (formally, for all i,j\nsuch that si=1 and sj=0, qi>qj\n\n    should hold). \n\nAmong all valid permutations q\nfind the one that has the smallest value of ∑i=1n|pi−qi|, where |x| is an absolute value of x\n\n.\n\nPrint the permutation q1,q2,…,qn\n\n. If there are multiple answers, you can print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains a single integer n\n(1≤n≤2⋅105\n\n) — the number of songs.\n\nThe second line of each testcase contains n\nintegers p1,p2,…,pn (1≤pi≤n\n\n) — the permutation of the predicted ratings.\n\nThe third line contains a single string s\n, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1\n\nmeans that he liked it.\n\nThe sum of n\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a permutation q\n — the re-evaluated ratings of the songs. If there are multiple answers such that ∑i=1n|pi−qi|\n\nis minimum possible, you can print any of them.\nExample\nInput\nCopy\n\n3\n2\n1 2\n10\n3\n3 1 2\n111\n8\n2 3 1 8 5 4 7 6\n01110001\n\nOutput\nCopy\n\n2 1\n3 1 2\n1 6 5 8 3 2 4 7\n\nNote\n\nIn the first testcase, there exists only one permutation q\nsuch that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. ∑i=1n|pi−qi|=|1−2|+|2−1|=2\n\n.\n\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p\n. Its cost is 0."
        },
        {
            "problem": "C",
            "task": "C. Set or Decrease\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given an integer array a1,a2,…,an\nand integer k\n\n.\n\nIn one step you can\n\n    either choose some index i\n\nand decrease ai by one (make ai=ai−1\n);\nor choose two indices i\nand j and set ai equal to aj (make ai=aj\n\n    ). \n\nWhat is the minimum number of steps you need to make the sum of array ∑i=1nai≤k\n\n? (You are allowed to make values of array negative).\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of test cases.\n\nThe first line of each test case contains two integers n\nand k (1≤n≤2⋅105; 1≤k≤1015) — the size of array a\n\nand upper bound on its sum.\n\nThe second line of each test case contains n\nintegers a1,a2,…,an (1≤ai≤109\n\n) — the array itself.\n\nIt's guaranteed that the sum of n\nover all test cases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print one integer — the minimum number of steps to make ∑i=1nai≤k\n\n.\nExample\nInput\nCopy\n\n4\n1 10\n20\n2 69\n6 9\n7 8\n1 2 1 3 1 2 1\n10 1\n1 2 3 1 2 6 1 6 8 10\n\nOutput\nCopy\n\n10\n0\n2\n7\n\nNote\n\nIn the first test case, you should decrease a1\n10 times to get the sum lower or equal to k=10\n\n.\n\nIn the second test case, the sum of array a\nis already less or equal to 69\n\n, so you don't need to change it.\n\nIn the third test case, you can, for example:\n\n    set a4=a3=1\n\n;\ndecrease a4\nby one, and get a4=0\n\n    . \n\nAs a result, you'll get array [1,2,1,0,1,2,1] with sum less or equal to 8 in 1+1=2 steps.\n\nIn the fourth test case, you can, for example:\n\n    choose a7\n\nand decrease in by one 3 times; you'll get a7=−2\n;\nchoose 4\nelements a6, a8, a9 and a10 and them equal to a7=−2\n\n    . \n\nAs a result, you'll get array [1,2,3,1,2,−2,−2,−2,−2,−2] with sum less or equal to 1 in 3+4=7 steps."
        },
        {
            "problem": "D",
            "task": "D. Shuffle\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a binary string (i. e. a string consisting of characters 0 and/or 1) s\nof length n. You can perform the following operation with the string s at most once: choose a substring (a contiguous subsequence) of s having exactly k\n\ncharacters 1 in it, and shuffle it (reorder the characters in the substring as you wish).\n\nCalculate the number of different strings which can be obtained from s\n\nby performing this operation at most once.\nInput\n\nThe first line contains two integers n\nand k (2≤n≤5000; 0≤k≤n\n\n).\n\nThe second line contains the string s\nof length n\n\n, consisting of characters 0 and/or 1.\nOutput\n\nPrint one integer — the number of different strings which can be obtained from s\nby performing the described operation at most once. Since the answer can be large, output it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n7 2\n1100110\n\nOutput\nCopy\n\n16\n\nInput\nCopy\n\n5 0\n10010\n\nOutput\nCopy\n\n1\n\nInput\nCopy\n\n8 1\n10001000\n\nOutput\nCopy\n\n10\n\nInput\nCopy\n\n10 8\n0010011000\n\nOutput\nCopy\n\n1\n\nNote\n\nSome strings you can obtain in the first example:\n\n    to obtain 0110110, you can take the substring from the 1\n\n-st character to the 4\n-th character, which is 1100, and reorder its characters to get 0110;\nto obtain 1111000, you can take the substring from the 3\n-rd character to the 7\n-th character, which is 00110, and reorder its characters to get 11000;\nto obtain 1100101, you can take the substring from the 5\n-th character to the 7\n\n    -th character, which is 110, and reorder its characters to get 101. \n\nIn the second example, k=0\nso you can only choose the substrings consisting only of 0 characters. Reordering them doesn't change the string at all, so the only string you can obtain is 10010."
        },
        {
            "problem": "E",
            "task": "E. Math Test\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nPetya is a math teacher. n\nof his students has written a test consisting of m\n\nquestions. For each student, it is known which questions he has answered correctly and which he has not.\n\nIf the student answers the j\n-th question correctly, he gets pj points (otherwise, he gets 0 points). Moreover, the points for the questions are distributed in such a way that the array p is a permutation of numbers from 1 to m\n\n.\n\nFor the i\n-th student, Petya knows that he expects to get xi points for the test. Petya wonders how unexpected the results could be. Petya believes that the surprise value of the results for students is equal to ∑i=1n|xi−ri|, where ri is the number of points that the i\n\n-th student has got for the test.\n\nYour task is to help Petya find such a permutation p\n\nfor which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of test cases.\n\nThe first line of each test case contains two integers n\nand m (1≤n≤10; 1≤m≤104\n\n) — the number of students and the number of questions, respectively.\n\nThe second line contains n\nintegers x1,x2,…,xn (0≤xi≤m(m+1)2), where xi is the number of points that the i\n\n-th student expects to get.\n\nThis is followed by n\nlines, the i-th line contains the string si (|si|=m;si,j∈{0,1}), where si,j is 1 if the i-th student has answered the j-th question correctly, and 0\n\notherwise.\n\nThe sum of m\nfor all test cases does not exceed 104\n\n.\nOutput\n\nFor each test case, print m\nintegers — a permutation p\n\nfor which the surprise value of the results is maximum possible. If there are multiple answers, print any of them.\nExample\nInput\nCopy\n\n3\n4 3\n5 1 2 2\n110\n100\n101\n100\n4 4\n6 2 0 10\n1001\n0010\n0110\n0101\n3 6\n20 3 15\n010110\n000101\n111111\n\nOutput\nCopy\n\n3 1 2 \n2 3 4 1 \n3 1 4 5 2 6 \n"
        },
        {
            "problem": "F",
            "task": "F. Quadratic Set\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nLet's call a set of positive integers a1,a2,…,ak\nquadratic if the product of the factorials of its elements is a square of an integer, i. e. ∏i=1kai!=m2, for some integer m\n\n.\n\nYou are given a positive integer n\n\n.\n\nYour task is to find a quadratic subset of a set 1,2,…,n\n\nof maximum size. If there are multiple answers, print any of them.\nInput\n\nA single line contains a single integer n\n(1≤n≤106\n\n).\nOutput\n\nIn the first line, print a single integer — the size of the maximum subset. In the second line, print the subset itself in an arbitrary order.\nExamples\nInput\nCopy\n\n1\n\nOutput\nCopy\n\n1\n1 \n\nInput\nCopy\n\n4\n\nOutput\nCopy\n\n3\n1 3 4 \n\nInput\nCopy\n\n7\n\nOutput\nCopy\n\n4\n1 4 5 6 \n\nInput\nCopy\n\n9\n\nOutput\nCopy\n\n7\n1 2 4 5 6 7 9 \n"
        }
    ],
    "/contest/1644": [
        {
            "problem": "A",
            "task": "A. Doors and Keys\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThe knight is standing in front of a long and narrow hallway. A princess is waiting at the end of it.\n\nIn a hallway there are three doors: a red door, a green door and a blue door. The doors are placed one after another, however, possibly in a different order. To proceed to the next door, the knight must first open the door before.\n\nEach door can be only opened with a key of the corresponding color. So three keys: a red key, a green key and a blue key — are also placed somewhere in the hallway. To open the door, the knight should first pick up the key of its color.\n\nThe knight has a map of the hallway. It can be transcribed as a string, consisting of six characters:\n\n    R, G, B — denoting red, green and blue doors, respectively;\n    r, g, b — denoting red, green and blue keys, respectively. \n\nEach of these six characters appears in the string exactly once.\n\nThe knight is standing at the beginning of the hallway — on the left on the map.\n\nGiven a map of the hallway, determine if the knight can open all doors and meet the princess at the end of the hallway.\nInput\n\nThe first line contains a single integer t\n(1≤t≤720\n\n) — the number of testcases.\n\nEach testcase consists of a single string. Each character is one of R, G, B (for the doors), r, g, b (for the keys), and each of them appears exactly once.\nOutput\n\nFor each testcase, print YES if the knight can open all doors. Otherwise, print NO.\nExample\nInput\nCopy\n\n4\nrgbBRG\nRgbrBG\nbBrRgG\nrgRGBb\n\nOutput\nCopy\n\nYES\nNO\nYES\nNO\n\nNote\n\nIn the first testcase, the knight first collects all keys, then opens all doors with them.\n\nIn the second testcase, there is a red door right in front of the knight, but he doesn't have a key for it.\n\nIn the third testcase, the key to each door is in front of each respective door, so the knight collects the key and uses it immediately three times.\n\nIn the fourth testcase, the knight can't open the blue door."
        },
        {
            "problem": "B",
            "task": "B. Anti-Fibonacci Permutation\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nLet's call a permutation p\nof length n anti-Fibonacci if the condition pi−2+pi−1≠pi holds for all i (3≤i≤n). Recall that the permutation is the array of length n which contains each integer from 1 to n\n\nexactly once.\n\nYour task is for a given number n\nprint n distinct anti-Fibonacci permutations of length n\n\n.\nInput\n\nThe first line contains a single integer t\n(1≤t≤48\n\n) — the number of test cases.\n\nThe single line of each test case contains a single integer n\n(3≤n≤50\n\n).\nOutput\n\nFor each test case, print n\nlines. Each line should contain an anti-Fibonacci permutation of length n\n\n. In each test case, you cannot print any permutation more than once.\n\nIf there are multiple answers, print any of them. It can be shown that it is always possible to find n\ndifferent anti-Fibonacci permutations of size n\n\nunder the constraints of the problem.\nExample\nInput\nCopy\n\n2\n4\n3\n\nOutput\nCopy\n\n4 1 3 2\n1 2 4 3\n3 4 1 2\n2 4 1 3\n3 2 1\n1 3 2\n3 1 2\n\n"
        },
        {
            "problem": "C",
            "task": "C. Increase Subarray Sums\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given an array a1,a2,…,an\n, consisting of n integers. You are also given an integer value x\n\n.\n\nLet f(k)\nbe the maximum sum of a contiguous subarray of a after applying the following operation: add x to the elements on exactly k distinct positions. An empty subarray should also be considered, it has sum 0\n\n.\n\nNote that the subarray doesn't have to include all of the increased elements.\n\nCalculate the maximum value of f(k)\nfor all k from 0 to n\n\nindependently.\nInput\n\nThe first line contains a single integer t\n(1≤t≤5000\n\n) — the number of testcases.\n\nThe first line of the testcase contains two integers n\nand x (1≤n≤5000; 0≤x≤105\n\n) — the number of elements in the array and the value to add.\n\nThe second line contains n\nintegers a1,a2,…,an (−105≤ai≤105\n\n).\n\nThe sum of n\nover all testcases doesn't exceed 5000\n\n.\nOutput\n\nFor each testcase, print n+1\nintegers — the maximum value of f(k) for all k from 0 to n\n\nindependently.\nExample\nInput\nCopy\n\n3\n4 2\n4 1 3 2\n3 5\n-2 -7 -1\n10 2\n-6 -1 -2 4 -6 -1 -4 4 -5 -4\n\nOutput\nCopy\n\n10 12 14 16 18\n0 4 4 5\n4 6 6 7 7 7 7 8 8 8 8\n\nNote\n\nIn the first testcase, it doesn't matter which elements you add x\nto. The subarray with the maximum sum will always be the entire array. If you increase k elements by x, k⋅x\n\nwill be added to the sum.\n\nIn the second testcase:\n\n    For k=0\n\n, the empty subarray is the best option.\nFor k=1\n, it's optimal to increase the element at position 3. The best sum becomes −1+5=4 for a subarray [3,3]\n.\nFor k=2\n, it's optimal to increase the element at position 3 and any other element. The best sum is still 4 for a subarray [3,3]\n.\nFor k=3\n, you have to increase all elements. The best sum becomes (−2+5)+(−7+5)+(−1+5)=5 for a subarray [1,3]. "
        },
        {
            "problem": "D",
            "task": "D. Cross Coloring\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nThere is a sheet of paper that can be represented with a grid of size n×m\n: n rows and m\n\ncolumns of cells. All cells are colored in white initially.\n\nq\noperations have been applied to the sheet. The i\n\n-th of them can be described as follows:\n\n    xi\n\nyi — choose one of k non-white colors and color the entire row xi and the entire column yi\n\n    in it. The new color is applied to each cell, regardless of whether the cell was colored before the operation. \n\nThe sheet after applying all q\n\noperations is called a coloring. Two colorings are different if there exists at least one cell that is colored in different colors.\n\nHow many different colorings are there? Print the number modulo 998244353\n\n.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of the testcase contains four integers n,m,k\nand q (1≤n,m,k,q≤2⋅105\n\n) — the size of the sheet, the number of non-white colors and the number of operations.\n\nThe i\n-th of the following q lines contains a description of the i-th operation — two integers xi and yi (1≤xi≤n; 1≤yi≤m\n\n) — the row and the column the operation is applied to.\n\nThe sum of q\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the number of different colorings modulo 998244353\n\n.\nExample\nInput\nCopy\n\n2\n1 1 3 2\n1 1\n1 1\n2 2 2 3\n2 1\n1 1\n2 2\n\nOutput\nCopy\n\n3\n4\n"
        },
        {
            "problem": "E",
            "task": "E. Expand the Path\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nConsider a grid of size n×n\n. The rows are numbered top to bottom from 1 to n, the columns are numbered left to right from 1 to n\n\n.\n\nThe robot is positioned in a cell (1,1)\n\n. It can perform two types of moves:\n\n    D — move one cell down;\n    R — move one cell right. \n\nThe robot is not allowed to move outside the grid.\n\nYou are given a sequence of moves s\n\n — the initial path of the robot. This path doesn't lead the robot outside the grid.\n\nYou are allowed to perform an arbitrary number of modifications to it (possibly, zero). With one modification, you can duplicate one move in the sequence. That is, replace a single occurrence of D with DD or a single occurrence of R with RR.\n\nCount the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn't move outside the grid.\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe first line of each testcase contains the single integer n\n(2≤n≤108\n\n) — the number of rows and columns in the grid.\n\nThe second line of each testcase contains a non-empty string s\n\n, consisting only of characters D and R, — the initial path of the robot. This path doesn't lead the robot outside the grid.\n\nThe total length of strings s\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the number of cells such that there exists at least one sequence of modifications that the robot visits this cell on the modified path and doesn't move outside the grid.\nExample\nInput\nCopy\n\n3\n4\nRD\n5\nDRDRDRDR\n3\nD\n\nOutput\nCopy\n\n13\n9\n3\n\nNote\n\nIn the first testcase, it's enough to consider the following modified paths:\n\n    RD →\n\nRRD → RRRD → RRRDD → RRRDDD — this path visits cells (1,1), (1,2), (1,3), (1,4), (2,4), (3,4) and (4,4)\n;\nRD →\nRRD → RRDD → RRDDD — this path visits cells (1,1), (1,2), (1,3), (2,3), (3,3) and (4,3)\n;\nRD →\nRDD → RDDD — this path visits cells (1,1), (1,2), (2,2), (3,2) and (4,2)\n\n    . \n\nThus, the cells that are visited on at least one modified path are: (1,1)\n, (1,2), (1,3), (1,4), (2,2), (2,3), (2,4), (3,2), (3,3), (3,4), (4,2), (4,3) and (4,4)\n\n.\n\nIn the second testcase, there is no way to modify the sequence without moving the robot outside the grid. So the only visited cells are the ones that are visited on the path DRDRDRDR.\n\nIn the third testcase, the cells that are visited on at least one modified path are: (1,1)\n, (2,1) and (3,1)\n\n.\n\nHere are the cells for all testcases:"
        },
        {
            "problem": "F",
            "task": "F. Basis\ntime limit per test\n6 seconds\nmemory limit per test\n512 megabytes\n\nFor an array of integers a\n, let's define |a|\n\nas the number of elements in it.\n\nLet's denote two functions:\n\n    F(a,k)\n\nis a function that takes an array of integers a and a positive integer k. The result of this function is the array containing |a| first elements of the array that you get by replacing each element of a with exactly k copies of that element.\n\nFor example, F([2,2,1,3,5,6,8],2)\nis calculated as follows: first, you replace each element of the array with 2 copies of it, so you obtain [2,2,2,2,1,1,3,3,5,5,6,6,8,8]. Then, you take the first 7 elements of the array you obtained, so the result of the function is [2,2,2,2,1,1,3]\n\n.\nG(a,x,y)\nis a function that takes an array of integers a and two different integers x and y. The result of this function is the array a with every element equal to x replaced by y, and every element equal to y replaced by x.\n\nFor example, G([1,1,2,3,5],3,1)=[3,3,2,1,5]\n\n    .\n\nAn array a\nis a parent of the array b\n\nif:\n\n    either there exists a positive integer k\n\nsuch that F(a,k)=b\n;\nor there exist two different integers x\nand y such that G(a,x,y)=b\n\n    . \n\nAn array a\nis an ancestor of the array b if there exists a finite sequence of arrays c0,c1,…,cm (m≥0) such that c0 is a, cm is b, and for every i∈[1,m], ci−1 is a parent of ci\n\n.\n\nAnd now, the problem itself.\n\nYou are given two integers n\nand k. Your goal is to construct a sequence of arrays s1,s2,…,sm\n\nin such a way that:\n\n    every array si\n\ncontains exactly n elements, and all elements are integers from 1 to k\n;\nfor every array a\nconsisting of exactly n integers from 1 to k, the sequence contains at least one array si such that si is an ancestor of a\n\n    . \n\nPrint the minimum number of arrays in such sequence.\nInput\n\nThe only line contains two integers n\nand k (1≤n,k≤2⋅105\n\n).\nOutput\n\nPrint one integer — the minimum number of elements in a sequence of arrays meeting the constraints. Since the answer can be large, output it modulo 998244353\n\n.\nExamples\nInput\nCopy\n\n3 2\n\nOutput\nCopy\n\n2\n\nInput\nCopy\n\n4 10\n\nOutput\nCopy\n\n12\n\nInput\nCopy\n\n13 37\n\nOutput\nCopy\n\n27643508\n\nInput\nCopy\n\n1337 42\n\nOutput\nCopy\n\n211887828\n\nInput\nCopy\n\n198756 123456\n\nOutput\nCopy\n\n159489391\n\nInput\nCopy\n\n123456 198756\n\nOutput\nCopy\n\n460526614\n\nNote\n\nLet's analyze the first example.\n\nOne of the possible answers for the first example is the sequence [[2,1,2],[1,2,2]]\n. Every array of size 3 consisting of elements from 1 to 2\n\nhas an ancestor in this sequence:\n\n    for the array [1,1,1]\n\n, the ancestor is [1,2,2]: F([1,2,2],13)=[1,1,1]\n;\nfor the array [1,1,2]\n, the ancestor is [1,2,2]: F([1,2,2],2)=[1,1,2]\n;\nfor the array [1,2,1]\n, the ancestor is [2,1,2]: G([2,1,2],1,2)=[1,2,1]\n;\nfor the array [1,2,2]\n, the ancestor is [1,2,2]\n;\nfor the array [2,1,1]\n, the ancestor is [1,2,2]: G([1,2,2],1,2)=[2,1,1]\n;\nfor the array [2,1,2]\n, the ancestor is [2,1,2]\n;\nfor the array [2,2,1]\n, the ancestor is [2,1,2]: F([2,1,2],2)=[2,2,1]\n;\nfor the array [2,2,2]\n, the ancestor is [1,2,2]: G(F([1,2,2],4),1,2)=G([1,1,1],1,2)=[2,2,2]. "
        }
    ],
    "/contest/1633": [
        {
            "problem": "A",
            "task": "A. Div. 7\ntime limit per test\n2 seconds\nmemory limit per test\n512 megabytes\n\nYou are given an integer n\n. You have to change the minimum number of digits in it in such a way that the resulting number does not have any leading zeroes and is divisible by 7\n\n.\n\nIf there are multiple ways to do it, print any of them. If the given number is already divisible by 7\n\n, leave it unchanged.\nInput\n\nThe first line contains one integer t\n(1≤t≤990\n\n) — the number of test cases.\n\nThen the test cases follow, each test case consists of one line containing one integer n\n(10≤n≤999\n\n).\nOutput\n\nFor each test case, print one integer without any leading zeroes — the result of your changes (i. e. the integer that is divisible by 7\nand can be obtained by changing the minimum possible number of digits in n\n\n).\n\nIf there are multiple ways to apply changes, print any resulting number. If the given number is already divisible by 7\n\n, just print it.\nExample\nInput\nCopy\n\n3\n42\n23\n377\n\nOutput\nCopy\n\n42\n28\n777\n\nNote\n\nIn the first test case of the example, 42\nis already divisible by 7\n\n, so there's no need to change it.\n\nIn the second test case of the example, there are multiple answers — 28\n, 21 or 63\n\n.\n\nIn the third test case of the example, other possible answers are 357\n, 371 and 378. Note that you cannot print 077 or 77."
        },
        {
            "problem": "B",
            "task": "B. Minority\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a string s\n\n, consisting only of characters '0' and '1'.\n\nYou have to choose a contiguous substring of s\n\nand remove all occurrences of the character, which is a strict minority in it, from the substring.\n\nThat is, if the amount of '0's in the substring is strictly smaller than the amount of '1's, remove all occurrences of '0' from the substring. If the amount of '1's is strictly smaller than the amount of '0's, remove all occurrences of '1'. If the amounts are the same, do nothing.\n\nYou have to apply the operation exactly once. What is the maximum amount of characters that can be removed?\nInput\n\nThe first line contains a single integer t\n(1≤t≤104\n\n) — the number of testcases.\n\nThe only line of each testcase contains a non-empty string s\n, consisting only of characters '0' and '1'. The length of s doesn't exceed 2⋅105\n\n.\n\nThe total length of strings s\nover all testcases doesn't exceed 2⋅105\n\n.\nOutput\n\nFor each testcase, print a single integer — the maximum amount of characters that can be removed after applying the operation exactly once.\nExample\nInput\nCopy\n\n4\n01\n1010101010111\n00110001000\n1\n\nOutput\nCopy\n\n0\n5\n3\n0\n\nNote\n\nIn the first testcase, you can choose substrings \"0\", \"1\" or \"01\". In \"0\" the amount of '0' is 1\n, the amount of '1' is 0. '1' is a strict minority, thus all occurrences of it are removed from the substring. However, since there were 0\n\nof them, nothing changes. Same for \"1\". And in \"01\" neither of '0' or '1' is a strict minority. Thus, nothing changes. So there is no way to remove any characters.\n\nIn the second testcase, you can choose substring \"10101010101\". It contains 5\ncharacters '0' and 6\n\ncharacters '1'. '0' is a strict minority. Thus, you can remove all its occurrences. There exist other substrings that produce the same answer.\n\nIn the third testcase, you can choose substring \"011000100\". It contains 6\ncharacters '0' and 3 characters '1'. '1' is a strict minority. Thus, you can remove all its occurrences."
        },
        {
            "problem": "C",
            "task": "C. Kill the Monster\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nMonocarp is playing a computer game. In this game, his character fights different monsters.\n\nA fight between a character and a monster goes as follows. Suppose the character initially has health hC\nand attack dC; the monster initially has health hM and attack dM\n\n. The fight consists of several steps:\n\n    the character attacks the monster, decreasing the monster's health by dC\n\n;\nthe monster attacks the character, decreasing the character's health by dM\n;\nthe character attacks the monster, decreasing the monster's health by dC\n;\nthe monster attacks the character, decreasing the character's health by dM\n\n    ;\n    and so on, until the end of the fight. \n\nThe fight ends when someone's health becomes non-positive (i. e. 0\n\nor less). If the monster's health becomes non-positive, the character wins, otherwise the monster wins.\n\nMonocarp's character currently has health equal to hC\nand attack equal to dC. He wants to slay a monster with health equal to hM and attack equal to dM. Before the fight, Monocarp can spend up to k coins to upgrade his character's weapon and/or armor; each upgrade costs exactly one coin, each weapon upgrade increases the character's attack by w, and each armor upgrade increases the character's health by a\n\n.\n\nCan Monocarp's character slay the monster if Monocarp spends coins on upgrades optimally?\nInput\n\nThe first line contains one integer t\n(1≤t≤5⋅104\n\n) — the number of test cases. Each test case consists of three lines:\n\nThe first line contains two integers hC\nand dC (1≤hC≤1015; 1≤dC≤109\n\n) — the character's health and attack;\n\nThe second line contains two integers hM\nand dM (1≤hM≤1015; 1≤dM≤109\n\n) — the monster's health and attack;\n\nThe third line contains three integers k\n, w and a (0≤k≤2⋅105; 0≤w≤104; 0≤a≤1010\n\n) — the maximum number of coins that Monocarp can spend, the amount added to the character's attack with each weapon upgrade, and the amount added to the character's health with each armor upgrade, respectively.\n\nThe sum of k\nover all test cases does not exceed 2⋅105\n\n.\nOutput\n\nFor each test case, print YES if it is possible to slay the monster by optimally choosing the upgrades. Otherwise, print NO.\nExample\nInput\nCopy\n\n4\n25 4\n9 20\n1 1 10\n25 4\n12 20\n1 1 10\n100 1\n45 2\n0 4 10\n9 2\n69 2\n4 2 7\n\nOutput\nCopy\n\nYES\nNO\nYES\nYES\n\nNote\n\nIn the first example, Monocarp can spend one coin to upgrade weapon (damage will be equal to 5\n), then health during battle will change as follows: (hC,hM)=(25,9)→(25,4)→(5,4)→(5,−1)\n\n. The battle ended with Monocarp's victory.\n\nIn the second example, Monocarp has no way to defeat the monster.\n\nIn the third example, Monocarp has no coins, so he can't buy upgrades. However, the initial characteristics are enough for Monocarp to win.\n\nIn the fourth example, Monocarp has 4\ncoins. To defeat the monster, he has to spend 2 coins to upgrade weapon and 2 coins to upgrade armor."
        },
        {
            "problem": "D",
            "task": "D. Make Them Equal\ntime limit per test\n2 seconds\nmemory limit per test\n256 megabytes\n\nYou have an array of integers a\nof size n. Initially, all elements of the array are equal to 1. You can perform the following operation: choose two integers i (1≤i≤n) and x (x>0), and then increase the value of ai by ⌊aix⌋ (i.e. make ai=ai+⌊aix⌋\n\n).\n\nAfter performing all operations, you will receive ci\ncoins for all such i that ai=bi\n\n.\n\nYour task is to determine the maximum number of coins that you can receive by performing no more than k\n\noperations.\nInput\n\nThe first line contains a single integer t\n(1≤t≤100\n\n) — the number of test cases.\n\nThe first line of each test case contains two integers n\nand k (1≤n≤103;0≤k≤106\n\n) — the size of the array and the maximum number of operations, respectively.\n\nThe second line contains n\nintegers b1,b2,…,bn (1≤bi≤103\n\n).\n\nThe third line contains n\nintegers c1,c2,…,cn (1≤ci≤106\n\n).\n\nThe sum of n\nover all test cases does not exceed 103\n\n.\nOutput\n\nFor each test case, print one integer — the maximum number of coins that you can get by performing no more than k\n\noperations.\nExample\nInput\nCopy\n\n4\n4 4\n1 7 5 2\n2 6 5 2\n3 0\n3 5 2\n5 4 7\n5 9\n5 2 5 6 3\n5 9 1 9 7\n6 14\n11 4 6 2 8 16\n43 45 9 41 15 38\n\nOutput\nCopy\n\n9\n0\n30\n167\n"
        },
        {
            "problem": "E",
            "task": "E. Spanning Tree Queries\ntime limit per test\n4 seconds\nmemory limit per test\n256 megabytes\n\nYou are given a connected weighted undirected graph, consisting of n\nvertices and m\n\nedges.\n\nYou are asked k\nqueries about it. Each query consists of a single integer x. For each query, you select a spanning tree in the graph. Let the weights of its edges be w1,w2,…,wn−1. The cost of a spanning tree is ∑i=1n−1|wi−x| (the sum of absolute differences between the weights and x\n\n). The answer to a query is the lowest cost of a spanning tree.\n\nThe queries are given in a compressed format. The first p\n(1≤p≤k) queries q1,q2,…,qp are provided explicitly. For queries from p+1 to k, qj=(qj−1⋅a+b)modc\n\n.\n\nPrint the xor of answers to all queries.\nInput\n\nThe first line contains two integers n\nand m (2≤n≤50; n−1≤m≤300\n\n) — the number of vertices and the number of edges in the graph.\n\nEach of the next m\nlines contains a description of an undirected edge: three integers v, u and w (1≤v,u≤n; v≠u; 0≤w≤108\n\n) — the vertices the edge connects and its weight. Note that there might be multiple edges between a pair of vertices. The edges form a connected graph.\n\nThe next line contains five integers p,k,a,b\nand c (1≤p≤105; p≤k≤107; 0≤a,b≤108; 1≤c≤108\n\n) — the number of queries provided explicitly, the total number of queries and parameters to generate the queries.\n\nThe next line contains p\nintegers q1,q2,…,qp (0≤qj<c) — the first p\n\nqueries.\nOutput\n\nPrint a single integer — the xor of answers to all queries.\nExamples\nInput\nCopy\n\n5 8\n4 1 4\n3 1 0\n3 5 3\n2 5 4\n3 4 8\n4 3 4\n4 2 8\n5 3 9\n3 11 1 1 10\n0 1 2\n\nOutput\nCopy\n\n4\n\nInput\nCopy\n\n6 7\n2 4 0\n5 4 7\n2 4 0\n2 1 7\n2 6 1\n3 4 4\n1 4 8\n4 10 3 3 7\n3 0 2 1\n\nOutput\nCopy\n\n5\n\nInput\nCopy\n\n3 3\n1 2 50\n2 3 100\n1 3 150\n1 10000000 0 0 100000000\n75\n\nOutput\nCopy\n\n164\n\nNote\n\nThe queries in the first example are 0,1,2,3,4,5,6,7,8,9,0\n. The answers are 11,9,7,3,1,5,8,7,5,7,11\n\n.\n\nThe queries in the second example are 3,0,2,1,6,0,3,5,4,1\n. The answers are 14,19,15,16,11,19,14,12,13,16\n\n.\n\nThe queries in the third example are 75,0,0,…\n. The answers are 50,150,150,…\n\n.\n"
        },
        {
            "problem": "F",
            "task": "F. Perfect Matching\ntime limit per test\n12 seconds\nmemory limit per test\n512 megabytes\n\nYou are given a tree consisting of n\nvertices (numbered from 1 to n) and n−1 edges (numbered from 1 to n−1). Initially, all vertices except vertex 1\n\nare inactive.\n\nYou have to process queries of three types:\n\n    1\n\nv — activate the vertex v. It is guaranteed that the vertex v is inactive before this query, and one of its neighbors is active. After activating the vertex, you have to choose a subset of edges of the tree such that each active vertex is incident to exactly one chosen edge, and each inactive vertex is not incident to any of the chosen edges — in other words, this subset should represent a perfect matching on the active part of the tree. If any such subset of edges exists, print the sum of indices of edges in it; otherwise, print 0\n.\n2\n— queries of this type will be asked only right after a query of type 1, and there will be at most 10 such queries. If your answer to the previous query was 0, simply print 0\n; otherwise, print the subset of edges for the previous query as follows: first, print the number of edges in the subset, then print the indices of the chosen edges in ascending order. The sum of indices should be equal to your answer to the previous query.\n3\n\n    — terminate the program. \n\nNote that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions fflush in C++ and BufferedWriter.flush in Java languages after each writing in your program.\nInput\n\nThe first line contains one integer n\n(2≤n≤2⋅105\n\n) — the number of vertices of the tree.\n\nThen n−1\nlines follow. The i-th line contains two integers ui and vi (1≤ui,vi≤n; ui≠vi) — the endpoints of the i\n\n-th edge. These edges form a tree.\n\nThen the queries follow in the format described in the statement, one line per query. There will be at least 2\nand at most n+10 queries. The last query (and only the last one) will be of type 3. Note that you can read the i-th query only if you have already given the answer for the query i−1 (except for i=1\n\n).\n\nIf your answer for one of the queries is incorrect and the judging program recognizes it, instead of the next query, you may receive the integer 0\non a separate line. After receiving it, your program should terminate gracefully, and you will receive \"Wrong Answer\" verdict. If your program doesn't terminate, your solution may receive some other verdict, like \"Time Limit Exceeded\", \"Idleness Limit Exceeded\", etc. Note that the fact that your solution doesn't receive the integer 0\n\n, it does not mean that all your answers are correct, some of them will be checked only after your program is terminated.\nOutput\n\nFor each query of type 1\nor 2\n\n, print the answer on a separate line as described in the statement. Don't forget to flush the output.\nExample\nInput\nCopy\n\n6\n1 4\n6 1\n3 2\n1 2\n5 1\n1 4\n2\n1 2\n2\n1 3\n2\n1 5\n1 6\n2\n3\n\nOutput\nCopy\n\n1\n1 1\n0\n0\n4\n2 1 3\n0\n0\n0\n"
        }
    ]
}